// ----------------------------------------------------------------------------
// VGDD Main Skeleton
// This program is the starting point to build a VGDD-enabled GOL Application
// ----------------------------------------------------------------------------
// FileName:          vgdd_main.c
// Generated by:      VGDD [VGDDVERSION] MPLAB X Wizard [COPYRIGHT]
// Dependencies:      vgdd_main.h, [PROJECTFILENAME_SCREENSC], VGDD_[PROJECTFILENAME_SCREENSH]
// Compiler:          [COMPILER]
// Development Board: [DEVBOARD]
// Expansion Board:   [EXPANSIONBOARD]
// Display Board:     [DISPLAYBOARD] - Orientation: [DISP_ORIENTATION] degrees
// Company:           VirtualFab, with adapted parts from Microchip Technology Incorporated
//
// ----------------------------------------------------------------------------
// VirtualFab Software License Agreement:
// ----------------------------------------------------------------------------
// [COPYRIGHT] - All rights reserved.
// Redistribution and use in source and binary forms, with or without modification,
// are permitted provided that the following conditions are met:
// Redistributions of source code must retain the above and following copyright notices,
// this list of conditions and the following disclaimer.
// Neither the name of Fabio Violino or VirtualFab may be used to endorse or promote 
// products derived from this software without specific prior written permission.
//
// THIS SOFTWARE IS PROVIDED BY THE AUTHOR “AS IS” AND ANY EXPRESS OR IMPLIED WARRANTIES,
// INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS
// FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
// IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL,
// EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT 
// OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS 
// INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, 
// STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY 
// OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
//
// ----------------------------------------------------------------------------
// Microchip's Software License Agreement:
// ----------------------------------------------------------------------------
// Copyright © 2012 Microchip Technology Inc.  All rights reserved.
// Microchip licenses to you the right to use, modify, copy and distribute
// Software only when embedded on a Microchip microcontroller or digital
// signal controller, which is integrated into your product or third party
// product (pursuant to the sublicense terms in the accompanying license
// agreement).
//
// You should refer to the license agreement accompanying this Software
// for additional information regarding your rights and obligations.
//
// SOFTWARE AND DOCUMENTATION ARE PROVIDED “AS IS” WITHOUT WARRANTY OF ANY
// KIND, EITHER EXPRESS OR IMPLIED, INCLUDING WITHOUT LIMITATION, ANY WARRANTY
// OF MERCHANTABILITY, TITLE, NON-INFRINGEMENT AND FITNESS FOR A PARTICULAR
// PURPOSE. IN NO EVENT SHALL MICROCHIP OR ITS LICENSORS BE LIABLE OR
// OBLIGATED UNDER CONTRACT, NEGLIGENCE, STRICT LIABILITY, CONTRIBUTION,
// BREACH OF WARRANTY, OR OTHER LEGAL EQUITABLE THEORY ANY DIRECT OR INDIRECT
// DAMAGES OR EXPENSES INCLUDING BUT NOT LIMITED TO ANY INCIDENTAL, SPECIAL,
// INDIRECT, PUNITIVE OR CONSEQUENTIAL DAMAGES, LOST PROFITS OR LOST DATA,
// COST OF PROCUREMENT OF SUBSTITUTE GOODS, TECHNOLOGY, SERVICES, OR ANY
// CLAIMS BY THIRD PARTIES (INCLUDING BUT NOT LIMITED TO ANY DEFENSE THEREOF),
// OR OTHER SIMILAR COSTS.
//
// Author               Date        Comment
//
// VirtualFab        2012/01/29     First MPLAB X Wizard implementation 
// VirtualFab        2012/10/18     VGDD 4.1 Release
// VirtualFab        2014/07/04     VGDD 8.0 Release
// ----------------------------------------------------------------------------
#include "vgdd_main.h"

// Configuration bits
// <editor-fold defaultstate="collapsed" desc="Generated Code">
// VGDD_MPLABX_WIZARD_START_SECTION: ConfigBits *** DO NOT DELETE THIS LINE! ***
// These lines will be replaced by VGDD MPLAB X Wizard with lines for the ConfigBits Section
// Don't delete the starting and ending markers!
// VGDD_MPLABX_WIZARD_END_SECTION *** DO NOT DELETE THIS LINE! ***
// </editor-fold>

// --------------------------------------------------------------------
//                            LOCAL PROTOTYPES
// --------------------------------------------------------------------
#define WAIT_UNTIL_FINISH(x)    while(!x)
void InitializeBoard(void);
void TickTouchInit(void);
void ErrorTrap(XCHAR *message);

// --------------------------------------------------------------------
//                             FONTS USED
// --------------------------------------------------------------------
extern const FONT_FLASH FONTDEFAULT; // default GOL font

// MainHead
// <editor-fold defaultstate="collapsed" desc="Generated Code">
// VGDD_MPLABX_WIZARD_START_SECTION: MainHead *** DO NOT DELETE THIS LINE! ***
// VGDD_MPLABX_WIZARD_END_SECTION *** DO NOT DELETE THIS LINE! ***
// </editor-fold>

// --------------------------------------------------------------------
//                       GLOBAL VARIABLES FOR APPLICATION
// --------------------------------------------------------------------
volatile SCREEN_STATES screenState=SCREENSTATE_INIT; // current state of state machine
DWORD tick;
#if defined(USE_BITMAP_SD) || defined(USB_SUPPORT_HOST)
BYTE usbErrorCode; // USB error
#endif

// --------------------------------------------------------------------
//                                  MAIN
// --------------------------------------------------------------------

int main(void) {
    GOL_MSG msg; // GOL message structure to interact with GOL
    InitializeBoard(); // Initialize hardware
    // <editor-fold defaultstate="collapsed" desc="Generated Code">
// VGDD_MPLABX_WIZARD_START_SECTION: MainBeforeLoop *** DO NOT DELETE THIS LINE! ***
    // These lines will be replaced by VGDD MPLAB X Wizard with lines for the MainBeforeLoop Section
    // Don't delete the starting and ending markers!
    // VGDD_MPLABX_WIZARD_END_SECTION *** DO NOT DELETE THIS LINE! ***
// </editor-fold>

#if (defined (USE_COMM_PKT_MEDIA_USB) || defined (USE_COMM_PKT_MEDIA_SERIAL_PORT))
    CheckExternalFlashHex();
#endif

    // Main Loop
    while (1) {
        //ClrWdt(); Uncomment this if you are using WatchDog timer to clear it
        // <editor-fold defaultstate="collapsed" desc="Generated Code">
// VGDD_MPLABX_WIZARD_START_SECTION: MainLoop *** DO NOT DELETE THIS LINE! ***
        // These lines will be replaced by VGDD MPLAB X Wizard with lines for the MainLoop Section
        // Don't delete the starting and ending markers!
        // VGDD_MPLABX_WIZARD_END_SECTION *** DO NOT DELETE THIS LINE! ***
// </editor-fold>
        if (GOLDraw()) { // Draw GOL objects
            // Drawing is done here, process messages
            // <editor-fold defaultstate="collapsed" desc="Generated Code">
// VGDD_MPLABX_WIZARD_START_SECTION: MainFinishedDraw *** DO NOT DELETE THIS LINE! ***
            // These lines will be replaced by VGDD MPLAB X Wizard with lines for the MainFinishedDraw Section
            // Don't delete the starting and ending markers!
            // VGDD_MPLABX_WIZARD_END_SECTION *** DO NOT DELETE THIS LINE! ***
// </editor-fold>

            GOLMsg(&msg); // Process message
        }
        // The GUI is done.
        // Application "background" code goes here, i.e. handling network packets, etc...
    }
}

// Main
// <editor-fold defaultstate="collapsed" desc="Generated Code">
// VGDD_MPLABX_WIZARD_START_SECTION: Main *** DO NOT DELETE THIS LINE! ***
// These lines will be replaced by VGDD MPLAB X Wizard with lines for the Main Section
// Don't delete the starting and ending markers!
// VGDD_MPLABX_WIZARD_END_SECTION *** DO NOT DELETE THIS LINE! ***
// </editor-fold>

// --------------------------------------------------------------------
// Function: WORD GOLMsgCallback(WORD objMsg, OBJ_HEADER* pObj, GOL_MSG* pMsg)
// Input: objMsg - translated message for the object,
//        pObj - pointer to the object,
//        pMsg - pointer to the non-translated, raw GOL message
// Output: if the function returns non-zero the message will be processed by default
// Overview: this function must be implemented by user. GOLMsg() function calls it each
//           time the valid message for the object received
// --------------------------------------------------------------------

WORD GOLMsgCallback(WORD objMsg, OBJ_HEADER *pObj, GOL_MSG *pMsg) {
/*
Only if you have manually defined screens (not VGDD-generated),
put here below the switch structure to handle messages like this:
      
WORD id= GetObjID(pObj);
switch (screenState) {
    case DISPLAY_MAIN:
        switch (id) {
            case ID_BUTTON_MENU:
                if (objMsg == BTN_MSG_RELEASED) {
                    screenState = CREATE_MENU;
                    return (1);
                }
                                    .
                                    .
                                    .
        }
}
*/

    // The following single call handles messages from all VGDD-generated screens
    return (VGDD_[PROJECT_CLEAN_NAME]_MsgCallback(objMsg, pObj, pMsg));
}

// --------------------------------------------------------------------
// Function: WORD GOLDrawCallback()
// Output: if the function returns non-zero the draw control will be passed to GOL
// Overview: this function must be implemented by user. GOLDraw() function calls it each
//           time when GOL objects drawing is completed. User drawing should be done here.
//           GOL will not change color, line type and clipping region settings while
//           this function returns zero.
// --------------------------------------------------------------------

WORD GOLDrawCallback(void) {
/*
    Only if you have manually defined screens (not VGDD-generated),
    put here below the switch structure to handle screenstates like this:
    
        switch (screenState) {
            case CREATE_MAIN:
            CreateMain(); // create main window
            screenState = DISPLAY_MAIN; // switch to next state
            return (1);
        case DISPLAY_MAIN:
                .
                .
                .
    */

    // The following single call handles screenstate changes of all VGDD-generated screens
    return (VGDD_[PROJECT_CLEAN_NAME]_DrawCallback());
}

// --------------------------------------------------------------------
// Function: InitializeBoard()
// Input: none
// Output: none
// Overview: Initializes the hardware components including the PIC device
//           used.
// --------------------------------------------------------------------
void InitializeBoard(void)
{
// <editor-fold defaultstate="collapsed" desc="Generated Code">
// VGDD_MPLABX_WIZARD_START_SECTION: InitializeBoard *** DO NOT DELETE THIS LINE! ***
// These lines will be replaced by VGDD MPLAB X Wizard with lines for the InitializeBoard Section
// Don't delete the starting and ending markers!
// VGDD_MPLABX_WIZARD_END_SECTION *** DO NOT DELETE THIS LINE! ***
// </editor-fold>
}

// Output text message on screen and stop execution

void ErrorTrap(XCHAR *message) {
    SetColor(BLACK);
    ClearDevice();
    SetFont((void *) &FONTDEFAULT);
    SetColor(WHITE);
    while (!OutTextXY(0, 0, message));
}

// --------------------------------------------------------------------
// Function: Timer ISR 
// PreCondition: none
// Input: none
// Output: none
// Side Effects: none
// Overview: increments tick counter. Tick is approx. 1 ms.
// Note: none
// --------------------------------------------------------------------
#ifdef __PIC32MX__
    #if (defined (GFX_PICTAIL_V3E) && defined (PIC32_ETH_SK))
        #define __TICK_ISR    __ISR(_TIMER_3_VECTOR, IPL4AUTO)
        #define __TICK_TIMER TMR3
        #define __TICK_CLEAR_TIMER     mT3ClearIntFlag();
        #define __TICK_START_TIMER {OpenTimer3(T3_ON | T3_PS_1_8, TICK_PERIOD); \
                                    ConfigIntTimer3(T3_INT_ON | T3_INT_PRIOR_1);}
    #else
        #define __TICK_ISR    __ISR(_TIMER_4_VECTOR, IPL1AUTO)
        #define __TICK_TIMER TMR4
        #define __TICK_CLEAR_TIMER     mT4ClearIntFlag();
        #define __TICK_START_TIMER {OpenTimer4(T4_ON | T4_PS_1_8, TICK_PERIOD); \
                                    ConfigIntTimer4(T4_INT_ON | T4_INT_PRIOR_1);}
    #endif
#else
    #define __TICK_ISR         __attribute__((interrupt, shadow, auto_psv))
    #define __TICK_TIMER       TMR4
    #define __TICK_CLEAR_TIMER IFS1bits.T4IF = 0;
    #define __TICK_START_TIMER {TMR4 = 0;\
                                PR4 = TICK_PERIOD; \
                                IFS1bits.T4IF = 0; \
                                IEC1bits.T4IE = 1; \
                                T4CONbits.TON = 1; \
                                }
#endif

#define TICK_PRESCALER	16
int tickscaler;

void __TICK_ISR _T4Interrupt(void) {
    __TICK_TIMER = 0;
    if (tickscaler > TICK_PRESCALER) {
        tickscaler = 0;
        tick++;
    } else
        tickscaler++;
// <editor-fold defaultstate="collapsed" desc="Generated Code">
// VGDD_MPLABX_WIZARD_START_SECTION: Tick *** DO NOT DELETE THIS LINE! ***
// These lines will be replaced by VGDD MPLAB X Wizard with lines for the InitializeBoard Section
// Don't delete the starting and ending markers!
// VGDD_MPLABX_WIZARD_END_SECTION *** DO NOT DELETE THIS LINE! ***
// </editor-fold>

#if defined(FILESYSTEM_USE_FATFS)
    void disk_timerproc(void);
    disk_timerproc();
#endif
    // Clear flag
    __TICK_CLEAR_TIMER
}

// --------------------------------------------------------------------
// Function: void TickTouchInit(void)
// Input: none
// Output: none
// Overview: Initilizes the tick timer.
// --------------------------------------------------------------------

// Section: Tick Delay
#define SAMPLE_PERIOD       1000 // us
#define TICK_PERIOD         (GetPeripheralClock() / 8 / SAMPLE_PERIOD) // Prescaler is set to 8 so divide by 8 to have a 1ms timer period. Thanks Wolli
 
void TickTouchInit(void) {
    // Initialize Timer
    __TICK_START_TIMER
}

// C30 and C32 Exception Handlers
// If your code gets here, you either tried to read or write
// a NULL pointer, or your application overflowed the stack
// by having too many local variables or parameters declared.
#if defined(__C30__)
	void _ISR __attribute__((__no_auto_psv__)) _AddressError(void)
	{
	    Nop();
		Nop();
	}
	void _ISR __attribute__((__no_auto_psv__)) _StackError(void)
	{
	    Nop();
		Nop();
	}

#elif defined(__C32__)

static unsigned int _excep_addr;

void _general_exception_handler(unsigned cause, unsigned status) {
    XCHAR *strException;
    static XCHAR strException0[]={'i','n','t','e','r','r','u','p','t',0};
    static XCHAR strException4[]={'a','d','d','r','e','s','s',' ','e','r','r','o','r',' ','(','l','o','a','d',' ','o','r',' ','i','f','e','t','c','h',')',0};
    static XCHAR strException5[]={'a','d','d','r','e','s','s',' ','e','r','r','o','r',' ','(','s','t','o','r','e',')',0};
    static XCHAR strException6[]={'b','u','s',' ','e','r','r','o','r',' ','(','i','f','e','t','c','h',')',0};
    static XCHAR strException7[]={'b','u','s',' ','e','r','r','o','r',' ','(','l','o','a','d','/','s','t','o','r','e',')',0};
    static XCHAR strException8[]={'s','y','s','c','a','l','l',0};
    static XCHAR strException9[]={'b','r','e','a','k','p','o','i','n','t',0};
    static XCHAR strException10[]={'r','e','s','e','r','v','e','d',' ','i','n','s','t','r','u','c','t','i','o','n',0};
    static XCHAR strException11[]={'c','o','p','r','o','c','e','s','s','o','r',' ','u','n','u','s','a','b','l','e',0};
    static XCHAR strException12[]={'a','r','i','t','h','m','e','t','i','c',' ','o','v','e','r','f','l','o','w',0};
    static XCHAR strException13[]={'t','r','a','p',' ','(','d','i','v','i','d','e',' ','b','y',' ','z','e','r','o','?',')',0};
    static XCHAR strExceptionX[]={'O','t','h','e','r',' ','e','x','c','e','p','t','i','o','n',0};

    asm volatile("mfc0 %0,$14" : "=r" (_excep_addr));

    switch ((cause & 0x0000007C) >> 2) {
        case 0:
            strException = strException0;
            break;
        case 4:
            strException = strException4;
            break;
        case 5:
            strException = strException5;
            break;
        case 6:
            strException = strException6;
            break;
        case 7:
            strException = strException7;
            break;
        case 8:
            strException = strException8;
            break;
        case 9:
            strException = strException9;
            break;
        case 10:
            strException = strException10;
            break;
        case 11:
            strException = strException11;
            break;
        case 12:
            strException = strException12;
            break;
        case 13:
            strException = strException13;
            break;
        default:
            strException = strExceptionX;
            break;
    }
    ErrorTrap(strException);
    while (1);
}
#endif
