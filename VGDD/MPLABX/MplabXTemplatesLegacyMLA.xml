<?xml version="1.0" encoding="utf-8"?>
<MplabXWizard>
    <Option Name="chkUSBhost" Description="USB host support" AlternativeTo="chkFlashProgrammer" Disabled="false">
<![CDATA[
USB host support enables the USB port on the DevBoard to read for example a PenDrive.

Used in conjunction with PutImageFromSD enables the ability to store your big bitmaps on the PenDrive.
]]>
    </Option>
    <Option Name="chkPutImageFromSD" Description="PutImageFromSD support" AlternativeTo="chkFlashProgrammer,chkMPFS">
<![CDATA[
PutImageFromSD enables your application to retrieve big bitmaps from either a direct-attached SD memory card or an USB PenDrive.

Needs one of the FileSystem options: either check FSIO or FatFs support.
]]>
    </Option>
    <Option Name="chkFlashProgrammer" Description="Flash Memory Programmer support" AlternativeTo="chkPutImageFromSD,chkUSBhost" Disabled="false">
<![CDATA[
Enable this feature to be able to store big bitmaps into the onboard SPI FLASH chip of the GFX Pictail boards.
]]>
    </Option>
    <Option Name="chkPMP16" Description="Use 16 bit Parallel Port" AlternativeTo="chkPMP8" >
        <!--Default="True"-->
<![CDATA[
Enable this option to force usage of the PMP in 16-bit mode to drive the TFT when the board uses a display controller chip (SSD1926, S1D13517, etc.).

Note: set jumper on the board accordingly.

Not needed for DA210 and LCC boards which drive the display directly.
]]>
    </Option>
    <Option Name="chkPMP8" Description="Use 8 bit Parallel Port" AlternativeTo="chkPMP16">
<![CDATA[
Enable this option to force usage of the PMP in 8-bit mode to drive the TFT when the board uses a display controller chip (SSD1926, S1D13517, etc.).

Note: set jumper on the board accordingly.

Not needed for DA210 and LCC boards which drive the display directly.
]]>
    </Option>
    <Option Name="chkSPIFlash" Description="NVM: Use the SST25VF016 SPI Flash chip" AlternativeTo="chkSPIeeprom, chkDEE">
<![CDATA[
Enable usage of the chip on Graphics Pictail Plus boards as NVM for TouchScreen parameters
]]>
    </Option>
    <Option Name="chkSPIeeprom" Description="NVM: Use the MCHP25LC256 SPI EEPROM chip (Explorer16)" AlternativeTo="chkSPIFlash, chkDEE">
<![CDATA[
Enable usage of the EEPROM chip on Explorer16 as NVM for TouchScreen parameters
]]>
    </Option>
    <Option Name="chkDEE" Description="NVM: Use DEE - Data Eeprom Emulation support" AlternativeTo="chkSPIFlash, chkSPIeeprom">
<![CDATA[
DEE support enables using 3 pages of FLASH Program memory as EEPROM to store persistent values (NVM - Non Volatile Memory)

It uses optimized algorithm to preserve PIC FLASH memory life.

Documentation at http://www.microchip.com/stellent/idcplg?IdcService=SS_GET_PAGE&nodeId=2680&dDocName=en538000
]]>
    </Option>
    <Option Name="chkRTCC" Description="RTCC - Real Time Clock and Calendar support">
<![CDATA[
RTCC support enables using PIC's internal Real Time Clock to keep a current time and date for your application.

In conjunction with TCP/IP support, there's the automatic Network Time Protocol synchronization with internet Time.

Needed for FatFs to obtain a valid timestamp for created files.
]]>
    </Option>
    <Option Name="chkTCPIP" Description="TCP/IP stack">
<![CDATA[
Check this option to add TCP/IP stack to your GUI application and enable Web Server and/or other network services
]]>
    </Option>
    <Option Name="chkTCPIPDemoApp" Description="TCP/IP Demo Application" DependsOn="chkTCPIP">
<![CDATA[
Check this option to add Demo functions to manipulate GUI items from web
]]>
    </Option>
    <Option Name="chkWiFi" Description="WiFi stack (needs TCP/IP stack)" DependsOn="chkTCPIP">
<![CDATA[
Check this option to add WiFi stack to your GUI application. The TCP/IP stack must also be enabled.
]]>
    </Option>
    <Option Name="chkMPFS" Description="MPFS Flash FileSystem support" AlternativeTo="chkFSIO,chkFatFs,chkPutImageFromSD" >
        <!--Default="True"-->
<![CDATA[
Check this option to add MPFS FileSystem for your Web server application, to store webpages in PIC's FLASH memory (fastest).
]]>
    </Option>
    <Option Name="chkFSIO" Description="MDD FSIO FileSystem support for SD" AlternativeTo="chkMPFS,chkFatFs">
<![CDATA[
Check this option to add FSIO FileSystem for your Web server application, to store webpages on SD.
]]>
    </Option>
    <Option Name="chkFatFs" Description="MDD FatFs FileSystem support for SD" AlternativeTo="chkFSIO,chkMPFS">
<![CDATA[
Check this option to add FatFs FileSystem for your Web server application, to store webpages on SD (faster than FSIO).
Documentation at http://elm-chan.org/fsw/ff/00index_e.html
]]>
    </Option>
    <Option Name="chkDS18B20" Description="DS18B20 1-Wire(tm) temperature sensor support">
<![CDATA[
Dallas DS18B20 is one of the most precise digital temperature sensor on the market. 
It provides 9-bit to 12-bit Celsius temperature measurements and has an alarm function with nonvolatile user-programmable upper and lower trigger points.
The DS18B20 communicates over a 1-Wire bus that by definition requires only one data line (and ground) for communication with a central microprocessor. 
It has an operating temperature range of -55°C to +125°C and is accurate to ±0.5°C over the range of -10°C to +85°C. 
In addition, the DS18B20 can derive power directly from the data line (“parasite power”), eliminating the need for an external power supply. 
Each DS18B20 has a unique 64-bit serial code, which allows multiple DS18B20s to function on the same 1-Wire bus. 
Thus, it is simple to use one microprocessor to control many DS18B20s distributed over a large area.
http://datasheets.maximintegrated.com/en/ds/DS18B20.pdf
]]>
    </Option>
    <Option Name="chkPCAP" Description="PCAP - Projective Capacitive support for TouchScreen">
<![CDATA[
Check this option to add capacitive touch screen support. Supported controllers are :
MTCH6301 used in MCHP's PIC32 GUI Development Board with Projected Capacitive Touch http://www.microchip.com/Developmenttools/ProductDetails.aspx?PartNO=DM320015
FT5x06 used in many others TFTs, like NewHaven's NHD-4.3-480272EF-ATXL#-CTP http://www.newhavendisplay.com/nhd43480272efatxlctp-p-5572.html
]]>
    </Option>
    <DevelopmentBoards>
    </DevelopmentBoards>
    <PIMBoards>
    </PIMBoards>
    <ExpansionBoards>
    </ExpansionBoards>
    <DisplayBoards>
    </DisplayBoards>
    <Groups>
        <Group Name="GOL">
            <Code>
                <Section Name="MainHeader">
<![CDATA[
#include "[PROJECTFILENAME_SCREENSH]"
#include "[PROJECTFILENAME_HELPERH]"
]]>
                </Section>
            </Code>
            <Project>
                <Folder Name="Source Files/Graphics">
                    <AddFile>$MAL/Graphics/GOL.c</AddFile>
                    <AddFile>$MAL/Graphics/Primitive.c</AddFile>
                    <AddFile>$MAL/Graphics/GOLSchemeDefault.c</AddFile>
                    <AddFile>$MAL/Graphics/Button.c</AddFile>
                    <AddFile>$MAL/Graphics/Chart.c</AddFile>
                    <AddFile>$MAL/Graphics/CheckBox.c</AddFile>
                    <AddFile>$MAL/Graphics/EditBox.c</AddFile>
                    <AddFile>$MAL/Graphics/Grid.c</AddFile>
                    <AddFile>$MAL/Graphics/GroupBox.c</AddFile>
                    <AddFile>$MAL/Graphics/ListBox.c</AddFile>
                    <AddFile>$MAL/Graphics/Meter.c</AddFile>
                    <AddFile>$MAL/Graphics/Picture.c</AddFile>
                    <AddFile>$MAL/Graphics/ProgressBar.c</AddFile>
                    <AddFile>$MAL/Graphics/RadioButton.c</AddFile>
                    <AddFile>$MAL/Graphics/RoundDial.c</AddFile>
                    <AddFile>$MAL/Graphics/Slider.c</AddFile>
                    <AddFile>$MAL/Graphics/StaticText.c</AddFile>
                    <AddFile>$MAL/Graphics/TextEntry.c</AddFile>
                    <AddFile>$MAL/Graphics/Window.c</AddFile>
                    <AddFile>$MAL/Graphics/AnalogClock.c</AddFile>
                    <AddFile>$MAL/Graphics/DigitalMeter.c</AddFile>
                    <AddFile>$MAL/Graphics/Grid.c</AddFile>
                </Folder>
                <Folder Name="Header Files/Graphics">
                    <AddFile>$MAL/Include/Graphics/Graphics.h</AddFile>
                    <AddFile>$MAL/Include/Graphics/GOL.h</AddFile>
                    <AddFile>$MAL/Include/Graphics/Primitive.h</AddFile>
                    <AddFile>$MAL/Include/Graphics/Button.h</AddFile>
                    <AddFile>$MAL/Include/Graphics/Chart.h</AddFile>
                    <AddFile>$MAL/Include/Graphics/CheckBox.h</AddFile>
                    <AddFile>$MAL/Include/Graphics/EditBox.h</AddFile>
                    <AddFile>$MAL/Include/Graphics/Grid.h</AddFile>
                    <AddFile>$MAL/Include/Graphics/GroupBox.h</AddFile>
                    <AddFile>$MAL/Include/Graphics/ListBox.h</AddFile>
                    <AddFile>$MAL/Include/Graphics/Meter.h</AddFile>
                    <AddFile>$MAL/Include/Graphics/Picture.h</AddFile>
                    <AddFile>$MAL/Include/Graphics/ProgressBar.h</AddFile>
                    <AddFile>$MAL/Include/Graphics/RadioButton.h</AddFile>
                    <AddFile>$MAL/Include/Graphics/RoundDial.h</AddFile>
                    <AddFile>$MAL/Include/Graphics/Slider.h</AddFile>
                    <AddFile>$MAL/Include/Graphics/StaticText.h</AddFile>
                    <AddFile>$MAL/Include/Graphics/TextEntry.h</AddFile>
                    <AddFile>$MAL/Include/Graphics/Window.h</AddFile>
                    <AddFile>$MAL/Include/Graphics/AnalogClock.h</AddFile>
                    <AddFile>$MAL/Include/Graphics/DigitalMeter.h</AddFile>
                    <AddFile>$MAL/Include/Graphics/Grid.h</AddFile>
                </Folder>
            </Project>
        </Group>
        <Group Name="FileSystem">
            <Project>
                <Folder Name="Header Files/MDD File System" Option="chkMPFS">
                    <RemoveFile>FileSystem.h</RemoveFile>
                    <RemoveFile>FSIO.h</RemoveFile>
                    <RemoveFile>FSDefs.h</RemoveFile>
                    <RemoveFile>FSconfig.h</RemoveFile>
                    <RemoveFile>ff.h</RemoveFile>
                    <RemoveFile>ffconf.h</RemoveFile>
                    <RemoveFile>diskio.h</RemoveFile>
                    <RemoveFile>integer.h</RemoveFile>
                </Folder>
                <Folder Name="Source Files/MDD File System" Option="chkMPFS">
                    <RemoveFile>FileSystem.c</RemoveFile>
                    <RemoveFile>FSIO.c</RemoveFile>
                    <RemoveFile>SD-SPI.c</RemoveFile>
                    <RemoveFile>ff.c</RemoveFile>
                    <RemoveFile>mmcPIC32.c</RemoveFile>
                    <RemoveFile>ccsbcs.c</RemoveFile>
                    <EnableDisableDefine File="HardwareProfile.h">
                        <Disable>FILESYSTEM_USE_FATFS</Disable>
                        <Enable>FILESYSTEM_USE_MPFS2</Enable>
                        <Disable>FILESYSTEM_USE_MDD</Disable>
                    </EnableDisableDefine>
                </Folder>
                <Folder Name="Header Files/MDD File System" Option="chkFSIO">
                    <AddFile>$MAL/Include/MDD File System/FSIO.h</AddFile>
                    <AddFile>$MAL/Include/MDD File System/FSDefs.h</AddFile>
                    <AddVGDDFile>FileSystem.h</AddVGDDFile>
                    <AddVGDDFile>FSconfig.h</AddVGDDFile>
                    <RemoveFile>ff.h</RemoveFile>
                    <RemoveFile>ffconf.h</RemoveFile>
                    <RemoveFile>diskio.h</RemoveFile>
                    <RemoveFile>integer.h</RemoveFile>
                </Folder>
                <Folder Name="Source Files/MDD File System" Option="chkFSIO">
                    <AddVGDDFile>FileSystem.c</AddVGDDFile>
                    <AddFile>$MAL/MDD File System/FSIO.c</AddFile>
                    <RemoveFile>ff.c</RemoveFile>
                    <RemoveFile>mmcPIC32.c</RemoveFile>
                    <RemoveFile>ccsbcs.c</RemoveFile>
                    <EnableDisableDefine File="HardwareProfile.h">
                        <Disable>FILESYSTEM_USE_FATFS</Disable>
                        <Disable>FILESYSTEM_USE_MPFS2</Disable>
                        <Enable>FILESYSTEM_USE_MDD</Enable>
                    </EnableDisableDefine>
                </Folder>
                <Folder Name="Source Files/MDD File System" Option="!chkUSBHost,chkFSIO">
                    <AddFile>$MAL/MDD File System/SD-SPI.c</AddFile>
                    <EnableDisableDefine File="HardwareProfile.h">
                        <Enable>USE_SD_INTERFACE_WITH_SPI</Enable>
                    </EnableDisableDefine>
                </Folder>
                <Folder Name="Header Files/MDD File System" Option="chkFatFs">
                    <AddVGDDFile>FileSystem.h</AddVGDDFile>
                    <AddVGDDFile>ff.h</AddVGDDFile>
                    <AddVGDDFile>ffconf.h</AddVGDDFile>
                    <AddVGDDFile>diskio.h</AddVGDDFile>
                    <AddVGDDFile>integer.h</AddVGDDFile>
                    <AddVGDDFile>FSconfig.h</AddVGDDFile>
                    <RemoveFile>FSIO.h</RemoveFile>
                    <RemoveFile>FSDefs.h</RemoveFile>
                </Folder>
                <Folder Name="Source Files/MDD File System" Option="chkFatFs">
                    <AddVGDDFile>FileSystem.c</AddVGDDFile>
                    <AddVGDDFile>ff.c</AddVGDDFile>
                    <AddVGDDFile>mmcPIC32.c</AddVGDDFile>
                    <AddVGDDFile>ccsbcs.c</AddVGDDFile>
                    <RemoveFile>FSIO.c</RemoveFile>
                    <RemoveFile>SD-SPI.c</RemoveFile>
                    <EnableDisableDefine File="HardwareProfile.h">
                        <Enable>FILESYSTEM_USE_FATFS</Enable>
                        <Disable>FILESYSTEM_USE_MPFS2</Disable>
                        <Disable>FILESYSTEM_USE_MDD</Disable>
                    </EnableDisableDefine>
                </Folder>
            </Project>
            <Code>
                <Section Name="MainHeader" Option="chkFSIO">
<![CDATA[
#include "FileSystem.h"
]]>
                </Section>
                <Section Name="MainBeforeLoop" Option="chkFSIO">
<![CDATA[
    #if defined(MEDIA_SOFT_DETECT)
    FileCheckMedia(); // Check for SD card/USB Thumb drive if attached - only once when starting	
    #endif
]]>
                </Section>
                <Section Name="MainLoop" Option="chkFSIO">
<![CDATA[
    #if !defined(MEDIA_SOFT_DETECT)
    FileCheckMedia(); // Check for SD card/USB Thumb drive if attached 	
    #endif
]]>
                </Section>
                <Section Name="MainHeader" Option="chkFatFs">
<![CDATA[
#include "FileSystem.h"
]]>
                </Section>
                <Section Name="HardwareProfileHead" Option="chkFatFs">
<![CDATA[
#define STACK_USE_FATFS
]]>
                </Section>
                <Section Name="MainBeforeLoop" Option="chkFatFs">
<![CDATA[
    #if defined(MEDIA_SOFT_DETECT)
    FileCheckMedia(); // Check for SD card/USB Thumb drive if attached - only once when starting	
    #endif
]]>
                </Section>
                <Section Name="MainLoop" Option="chkFatFs">
<![CDATA[
    #if !defined(MEDIA_SOFT_DETECT)
    FileCheckMedia(); // Check for SD card/USB Thumb drive if attached 	
    #endif
]]>
                </Section>
                <Section Name="Main" Option="chkFatFs">
<![CDATA[

/*********************************************************************
 * Function:          DWORD get_fattime(void)
 * PreCondition:
 * Input:           None
 * Output:          Time
 * Side Effects:
 * Overview:        when writing fatfs requires a time stamp
 *                    in this exmaple we are going to use a counter
 *                    If the starter kit has the 32kHz crystal
 *                    installed then the < could be used instead
 * Note:
 ********************************************************************/
DWORD get_fattime(void) {
    DWORD tmr;

    RTCCProcessEvents();
     tmr = (( ((DWORD)(mRTCCDec2Bin(_time.yr)+20) << 25))
            | ((DWORD) (mRTCCDec2Bin(_time.mth)) << 21)
            | ((DWORD) (mRTCCDec2Bin(_time.day)) << 16)
            | (WORD) ((mRTCCDec2Bin(_time.hr) << 11))
            | (WORD) ((mRTCCDec2Bin(_time.min) << 5))
            | (WORD) ((mRTCCDec2Bin(_time.sec) >> 1)));

    return tmr;
}                                
]]>
                </Section>
            </Code>
        </Group>
        <Group Name="TouchScreenResistive">
            <Project>
                <Folder Name="Header Files/Board Support Package">
                    <AddFile>$MAL/../Board Support Package/TouchScreen.h</AddFile>
                    <AddFile>$MAL/../Board Support Package/TouchScreenResistive.h</AddFile>
                </Folder>
                <Folder Name="Source Files/Board Support Package">
                    <AddFile>$MAL/../Board Support Package/TouchScreen.c</AddFile>
                    <AddFile>$MAL/../Board Support Package/TouchScreenResistive.c</AddFile>
                </Folder>
            </Project>
            <Code>
                <Section Name="MainHeader">
                    #define SCREEN_TOUCHED()    (TouchGetX() != -1)
                </Section>
                <Section Name="MainFinishedDraw">
<![CDATA[
            TouchGetMsg(&msg); // Get message from touch screen
]]>
                </Section>
                <Section Name="Tick">
<![CDATA[
    TouchDetectPosition();
]]>
                </Section>
            </Code>
        </Group>
        <Group Name="SPIFlash">
            <Project>
                <Folder Name="Header Files/Board Support Package" Option="chkSPIFlash">
                    <AddFile>$MAL/../Board Support Package/SST25VF016.h</AddFile>
                    <AddFile>$MAL/../Board Support Package/drv_spi.h</AddFile>
                </Folder>
                <Folder Name="Source Files/Board Support Package" Option="chkSPIFlash">
                    <AddFile>$MAL/../Board Support Package/SST25VF016.c</AddFile>
                    <AddFile>$MAL/../Board Support Package/drv_spi.c</AddFile>
                </Folder>
            </Project>
            <Code>
                <Section Name="HardwareProfileHead" Option="chkSPIFlash">
<![CDATA[
#define USE_SST25VF016 // use the 16 Mbit SPI Serial Flash on GFX3 Pictail Plus boards
]]>
                </Section>
                <Section Name="MainHead" Option="chkSPIFlash" Family="PIC32">
<![CDATA[
// --------------------------------------------------------------------
// SPI Channel settings (for SPI Flash Memory) PIC32 family
// --------------------------------------------------------------------
const DRV_SPI_INIT_DATA SPI_Init_Data = {SST25_SPI_CHANNEL, 1, 0, 0, 1, 1, 0};
]]>
                </Section>
                <Section Name="MainHead" Option="chkSPIFlash" Family="PIC24">
<![CDATA[
// --------------------------------------------------------------------
// SPI Channel settings (for SPI Flash Memory) PIC24/dsPIC33 family
// --------------------------------------------------------------------
const DRV_SPI_INIT_DATA SPI_Init_Data = {SST25_SPI_CHANNEL, 3, 6, 0, 1, 1, 0};
]]>
                </Section>
                <Section Name="MainHead" Option="chkSPIFlash">
<![CDATA[

// --------------------------------------------------------------------
// SPI Device Initialization Function for SPI Flash Memory
// --------------------------------------------------------------------
// initialize GFX3 SST25 flash SPI
#define FlashInit(pInitData) SST25Init((DRV_SPI_INIT_DATA*)pInitData);
]]>
                </Section>
                <Section Name="MainHeader" Option="chkSPIFlash">
<![CDATA[
#include "drv_spi.h"
#include "SST25VF016.h"
]]>
                </Section>
                <Section Name="HardwareProfile" Option="chkSPIFlash">
<![CDATA[
// --------------------------------------------------------------------
// Touch Screen Non-Volatile Memory Storage Macros for SPI Flash Memory
// --------------------------------------------------------------------
#define ADDRESS_RESISTIVE_TOUCH_VERSION	(unsigned long)0xFFFFFFFE
#define ADDRESS_RESISTIVE_TOUCH_ULX   (unsigned long)0xFFFFFFFC
#define ADDRESS_RESISTIVE_TOUCH_ULY   (unsigned long)0xFFFFFFFA
#define ADDRESS_RESISTIVE_TOUCH_URX   (unsigned long)0xFFFFFFF8
#define ADDRESS_RESISTIVE_TOUCH_URY   (unsigned long)0xFFFFFFF6

#define ADDRESS_RESISTIVE_TOUCH_LLX   (unsigned long)0xFFFFFFF4
#define ADDRESS_RESISTIVE_TOUCH_LLY   (unsigned long)0xFFFFFFF2
#define ADDRESS_RESISTIVE_TOUCH_LRX   (unsigned long)0xFFFFFFF0
#define ADDRESS_RESISTIVE_TOUCH_LRY   (unsigned long)0xFFFFFFEE

#define NVMSectorErase ((NVM_SECTORERASE_FUNC)&SST25SectorErase)
#define NVMWrite       ((NVM_WRITE_FUNC)&SST25WriteWord)
#define NVMRead        ((NVM_READ_FUNC)&SST25ReadWord)
]]>
                </Section>
                <Section Name="InitializeBoard" Option="chkSPIFlash" Order="3">
<![CDATA[
    //The following are PIC device specific settings for the SPI channel
    //used.
    //Set IOs directions for SST25 SPI
    SST25_CS_LAT = 1;
    SST25_CS_TRIS = 0;
    #ifndef __PIC32MX__
        SST25_SCK_TRIS = 0;
        SST25_SDO_TRIS = 0;
        SST25_SDI_TRIS = 1;
        #if defined(__PIC24FJ256GB210__) || defined(__dsPIC33E__) || defined(__PIC24E__)
            SST25_SDI_ANS = 0;
        #endif
    #endif
    FlashInit(&SPI_Init_Data);   // initialize the Flash Memory driver
]]>
                </Section>
            </Code>
        </Group>
        <Group Name="SPI1Flash">
            <Code>
                <Section Name="HardwareProfile" Option="chkSPIFlash">
<![CDATA[
// --------------------------------------------------------------------
// SPI Flash Memory on GFXV3 Pictail Boards (SPI1)
// --------------------------------------------------------------------
// Set up the signals used to communicate to the SPI Flash device 

// define the SPI channel to be used
#define SST25_SPI_CHANNEL 1

/* Define all the SPI channels that will be used here.
    These will be used to determine how the SPI Driver (drv_spi)
    will be compiled.
*/
#define SPI_CHANNEL_1_ENABLE
]]>
                </Section>
            </Code>
        </Group>
        <Group Name="SPI2Flash">
            <Code>
                <Section Name="HardwareProfile" Option="chkSPIFlash" Condition="DEVBOARDID != PIC32_ETH_SK">
<![CDATA[
// --------------------------------------------------------------------
// SPI Flash Memory on GFXV3 Pictail Boards (SPI2)
// --------------------------------------------------------------------
// Set up the signals used to communicate to the SPI Flash device 

// define the SPI channel to be used
#define SST25_SPI_CHANNEL 2

/* Define all the SPI channels that will be used here.
    These will be used to determine how the SPI Driver (drv_spi)
    will be compiled.
*/
#define SPI_CHANNEL_2_ENABLE
]]>
                </Section>
                <Section Name="HardwareProfile" Option="chkSPIFlash" Condition="DEVBOARDID = PIC32_ETH_SK">
<![CDATA[
// --------------------------------------------------------------------
// SPI Flash Memory on GFXV3 Pictail Boards (SPI2)
// --------------------------------------------------------------------
// Set up the signals used to communicate to the SPI Flash device 

// define the SPI channel to be used
#define SST25_SPI_CHANNEL 1

/* Define all the SPI channels that will be used here.
    These will be used to determine how the SPI Driver (drv_spi)
    will be compiled.
*/
#define SPI_CHANNEL_1_ENABLE
]]>
                </Section>
            </Code>
        </Group>
        <Group Name="SPIeeprom">
            <Project>
                <Folder Name="Header Files/Board Support Package" Option="chkSPIeeprom">
                    <AddFile>$MAL/../Board Support Package/MCHP25LC256.h</AddFile>
                    <AddFile>$MAL/../Board Support Package/drv_spi.h</AddFile>
                </Folder>
                <Folder Name="Source Files/Board Support Package" Option="chkSPIeeprom">
                    <AddFile>$MAL/../Board Support Package/MCHP25LC256.c</AddFile>
                    <AddFile>$MAL/../Board Support Package/drv_spi.c</AddFile>
                </Folder>
            </Project>
            <Code>
                <Section Name="HardwareProfileHead" Option="chkSPIeeprom">
<![CDATA[
#define USE_MCHP25LC256    // use the 256Kbit SPI Serial Flash on EXPLORER16
]]>
                </Section>
                <Section Name="MainHead" Option="chkSPIeeprom">
<![CDATA[
// --------------------------------------------------------------------
// SPI Channel settings (for SPI Flash Memory) 
// --------------------------------------------------------------------
const DRV_SPI_INIT_DATA SPI_Init_Data = {MCHP25LC256_SPI_CHANNEL, 6, 3, 0, 1, 1, 0};    

// --------------------------------------------------------------------
// SPI Device Initialization Function for SPI Flash Memory
// --------------------------------------------------------------------
// initialize EEPROM on Explorer 16
#define FlashInit(pInitData) MCHP25LC256Init((DRV_SPI_INIT_DATA*)pInitData)  
]]>
                </Section>
                <Section Name="MainHeader" Option="chkSPIeeprom">
<![CDATA[
#include "drv_spi.h"
#include "MCHP25LC256.h"
]]>
                </Section>
                <Section Name="HardwareProfile" Option="chkSPIeeprom">
<![CDATA[
// --------------------------------------------------------------------
// Touch Screen Non-Volatile Memory Storage Macros
// --------------------------------------------------------------------
// for  MCHP25LC256 serial EEPROM or AT25256 serial EEPROM
// Addresses for calibration and version values in EEPROM on Explorer16
#define ADDRESS_RESISTIVE_TOUCH_VERSION	(unsigned long)0x7FFE
#define ADDRESS_RESISTIVE_TOUCH_ULX   (unsigned long)0x7FFC
#define ADDRESS_RESISTIVE_TOUCH_ULY   (unsigned long)0x7FFA
#define ADDRESS_RESISTIVE_TOUCH_URX   (unsigned long)0x7FF8
#define ADDRESS_RESISTIVE_TOUCH_URY   (unsigned long)0x7FF6

#define ADDRESS_RESISTIVE_TOUCH_LLX   (unsigned long)0x7FF4
#define ADDRESS_RESISTIVE_TOUCH_LLY   (unsigned long)0x7FF2
#define ADDRESS_RESISTIVE_TOUCH_LRX   (unsigned long)0x7FF0
#define ADDRESS_RESISTIVE_TOUCH_LRY   (unsigned long)0x7FEE

// define the functions to call for the non-volatile memory
// check out touch screen module for definitions of the following function pointers
// used: NVM_READ_FUNC, NVM_WRITE_FUNC & NVM_SECTORERASE_FUNC
#define NVMSectorErase  ((NVM_SECTORERASE_FUNC)0)
#define NVMWrite        ((NVM_WRITE_FUNC)&MCHP25LC256WriteWord)
#define NVMRead         ((NVM_READ_FUNC)&MCHP25LC256ReadWord)
]]>
                </Section>
                <Section Name="InitializeBoard" Option="chkSPIeeprom" Order="3">
<![CDATA[
    // Set IOs directions for 25LC256 EEPROM (Explorer16)
    MCHP25LC256_CS_LAT = 1;
    MCHP25LC256_CS_TRIS = 0;
    MCHP25LC256_SCK_TRIS = 0;
    MCHP25LC256_SDO_TRIS = 0;
    MCHP25LC256_SDI_TRIS = 1;
    FlashInit(&SPI_Init_Data);   // initialize the Flash Memory driver
]]>
                </Section>
            </Code>
        </Group>
        <Group Name="RTCC">
            <Project>
                <Folder Name="Source Files" Option="chkRTCC">
                    <AddVGDDFile>rtcc.c</AddVGDDFile>
                </Folder>
                <Folder Name="Header Files" Option="chkRTCC">
                    <AddVGDDFile>rtcc.h</AddVGDDFile>
                </Folder>
            </Project>
            <Code>
                <Section Name="ConfigBits" Family="PIC32" Condition="DEVBOARDID != PIC32_PCAP">
<![CDATA[
#pragma config FSOSCEN = ON         // Secondary Oscillator Enable for RTCC
]]>
                </Section>
                <Section Name="MainHeader" Option="chkRTCC">
<![CDATA[
        #include "rtcc.h"
]]>
                </Section>

                <Section Name="InitializeBoard" Option="chkRTCC" Order="8">
<![CDATA[
    RTCCInit(); // Setup the RTCC
    // while(RtccGetClkStat() != RTCC_CLK_ON); // Uncomment this line if you want to wait for RTCC to start
    RTCCProcessEvents();
]]>
                </Section>
                <Section Name="MainLoop" Option="chkRTCC">
<![CDATA[
#if defined(USE_STATICTEXT)
        // --------------------------------------------------------------------
        // Update screen date & time from RTCC
        // --------------------------------------------------------------------
        STATICTEXT *pTxt=NULL;
        static BYTE secs;
        RTCCProcessEvents();
        if(_time.sec!=secs) {
            secs=_time.sec;
            // Replace ID_Screen1_txtRTCC with your StaticText ID for date & time display
    #if defined(ID_Screen1_txtRTCC)
            pTxt=(STATICTEXT *)GOLFindObject(ID_Screen1_txtRTCC); 
    #endif
            if(pTxt!=NULL) {
                strncpypgm2ram(pTxt->pText,&_time_str[0],3); // Copy day of week
                strncpypgm2ram(pTxt->pText+4,&_date_str[0],12); // Copy Date
                strncpypgm2ram(pTxt->pText+17,&_time_str[4],8); // Copy Hour
                SetState(pTxt, ST_DRAW);
            }
        }
#endif
]]>
                </Section>
            </Code>
        </Group>
        <Group Name="USBhost">
            <Project>
                <Folder Name="Header Files/USB" Option="chkUSBhost">
                    <AddFile>$MAL/Include/USB/usb.h</AddFile>
                    <AddFile>$MAL/USB/usb_host_local.h</AddFile>
                    <AddFile>$MAL/USB/usb_hal_local.h</AddFile>
                    <AddFile>$MAL/Include/USB/usb_common.h</AddFile>
                    <AddFile>$MAL/Include/USB/usb_ch9.h</AddFile>
                    <AddFile>$MAL/Include/USB/usb_host.h</AddFile>
                    <AddFile>$MAL/Include/USB/usb_hal.h</AddFile>
                </Folder>
                <Folder Name="Source Files/USB" Option="chkUSBhost">
                    <AddFile>$MAL/USB/usb_host.c</AddFile>
                    <AddFile>$MAL/USB/MSD Host Driver/usb_host_msd.c</AddFile>
                    <AddFile>$MAL/USB/MSD Host Driver/usb_host_msd_scsi.c</AddFile>
                </Folder>
                <Folder Name="Source Files" Option="chkUSBhost">
                    <AddVGDDFile>usb_config.c</AddVGDDFile>
                </Folder>
                <Folder Name="Header Files" Option="chkUSBhost">
                    <AddVGDDFile>usb_config.h</AddVGDDFile>
                </Folder>
            </Project>
            <Code>
                <Section Name="HardwareProfileHead" Option="chkUSBhost">
<![CDATA[
#define USB_SUPPORT_HOST  // For USB
#define USE_USB_INTERFACE // For FSIO.c
]]>
                </Section>
                <Section Name="MainHeader" Option="chkUSBhost">
<![CDATA[
#include "usb_config.h"
#include "USB/usb.h"
#include "USB/usb_host_msd.h"
#include "USB/usb_host_hid_parser.h"
#include "USB/usb_host_hid.h"
#include "USB/usb_host_msd_scsi.h"
]]>
                </Section>
                <Section Name="MainHead" Option="chkUSBhost">
<![CDATA[
// --------------------------------------------------------------------
//                         STRINGS USED BY USB
// --------------------------------------------------------------------
const XCHAR ErrMsgStandard[] = {'U', 'S', 'B', ' ', 'E', 'r', 'r', 'o', 'r', 0};
const XCHAR ErrNotSupported[] = {'n', 'o', 't', ' ', 's', 'u', 'p', 'p', 'o', 'r', 't', 'e', 'd', '!', 0};
const XCHAR ErrMsgFailedStr[] = {'F', 'a', 'i', 'l', 'e', 'd', 0};
const XCHAR ErrMsgHUBAttachedStr[] = {'H', 'U', 'B', 0};
const XCHAR ErrMsgUDAttachedStr[] = {'D', 'e', 'v', 'i', 'c', 'e', 0};
const XCHAR ErrMsgEnumerationStr[] = {'E', 'n', 'u', 'm', 'e', 'r', 'a', 't', 'i', 'o', 'n', 0};
const XCHAR ErrMsgClientInitStr[] = {'C', 'l', 'i', 'e', 'n', 't', ' ', 'I', 'n', 'i', 't', 'i', 'a', 'l', 'i', 'z', 'a', 't', 'i', 'o', 'n', 0};
const XCHAR ErrMsgOutofMemoryStr[] = {'O', 'u', 't', ' ', 'o', 'f', ' ', 'M', 'e', 'm', 'o', 'r', 'y', 0};
const XCHAR ErrMsgUnpecifiedErrStr[] = {'U', 'n', 's', 'p', 'e', 'c', 'i', 'f', 'i', 'e', 'd', 0};
const XCHAR MsgTouchToProceedStr[] = {'T', 'o', 'u', 'c', 'h', ' ', 't', 'o', ' ', 'p', 'r', 'o', 'c', 'e', 'e', 'd', 0};
BYTE usbErrorCode; // USB error
				]]>
                </Section>
                <Section Name="Main" Option="chkUSBhost">
<![CDATA[
/****************************************************************************
  Function:
    BOOL USB_ApplicationEventHandler( BYTE address, USB_EVENT event,
                    void *data, DWORD size )
  Description: 	This routine handles USB events sent from the USB Embedded Host stack.
  Precondition: None
  Parameters:	BYTE address    - Address of the USB device generating the event
				USB_EVENT event - Event that has occurred
				void *data      - Pointer to the data associated with the event
				DWORD size      - Size of the data pointed to by *data
  Return Values: TRUE   - The event was handled successfully
				FALSE   - The even was not handled successfully
  Remarks:
    We will default to returning TRUE for unknown events, and let operation
    proceed.  Other applications may wish to return FALSE, since we are not
    really handling the event.
 ***************************************************************************/
BOOL USB_ApplicationEventHandler(BYTE address, USB_EVENT event, void *data, DWORD size) {
    WORD yPos, TextHeight;

    switch (event) {
        case EVENT_VBUS_REQUEST_POWER:

            // We will let everything attach.
            return (TRUE);

        case EVENT_VBUS_RELEASE_POWER:

            // We are not monitoring power allocation, so we have
            // nothing to update.
            return (TRUE);

        case EVENT_HUB_ATTACH:
        case EVENT_UNSUPPORTED_DEVICE:
        case EVENT_CANNOT_ENUMERATE:
        case EVENT_CLIENT_INIT_ERROR:
        case EVENT_OUT_OF_MEMORY:
        case EVENT_UNSPECIFIED_ERROR: // This should never occur
            usbErrorCode = USBHostDeviceStatus(1);

                    // Shut down the USB.
                    //USBHostShutdown();
            break;

        default:
            return (FALSE);
    }

    //    // USB error messages will only appear when in the Menu Screens.
    //    if(screenState != DISPLAY_DEMOSELECTION)
    //        return (TRUE);

    // go back to initial screen when exiting this function.
    screenState = SCREENSTATE_INIT;

            // The following code displays the different USB errors that can
            // occur. Example, inserting an unsupported device or device
            // does not enumerate.
            // clear the screen
            SetColor(WHITE);
            ClearDevice();

            // set up the font to display the error messages
            SetFont((void *) &FONTDEFAULT);
            SetColor(BRIGHTBLUE);
            TextHeight = GetTextHeight((void *) &FONTDEFAULT);
            yPos = TextHeight * 2;

            // output the standard USB error string
            MoveTo((GetMaxX() - GetTextWidth((XCHAR *) ErrMsgStandard, (void *) &FONTDEFAULT)) >> 1, yPos);
            WAIT_UNTIL_FINISH(OutText((XCHAR *) ErrMsgStandard));
            yPos += TextHeight;

    switch (event) {
        case EVENT_HUB_ATTACH:
            MoveTo((GetMaxX() - GetTextWidth((XCHAR *) ErrMsgHUBAttachedStr, (void *) &FONTDEFAULT)) >> 1, yPos);
                    WAIT_UNTIL_FINISH(OutText((XCHAR *) ErrMsgHUBAttachedStr));
                    yPos += TextHeight;
                    MoveTo((GetMaxX() - GetTextWidth((XCHAR *) ErrNotSupported, (void *) &FONTDEFAULT)) >> 1, yPos);
                    WAIT_UNTIL_FINISH(OutText((XCHAR *) ErrNotSupported));
            break;

        case EVENT_UNSUPPORTED_DEVICE:
            MoveTo((GetMaxX() - GetTextWidth((XCHAR *) ErrMsgUDAttachedStr, (void *) &FONTDEFAULT)) >> 1, yPos);
                    WAIT_UNTIL_FINISH(OutText((XCHAR *) ErrMsgUDAttachedStr));
                    yPos += TextHeight;
                    MoveTo((GetMaxX() - GetTextWidth((XCHAR *) ErrNotSupported, (void *) &FONTDEFAULT)) >> 1, yPos);
                    WAIT_UNTIL_FINISH(OutText((XCHAR *) ErrNotSupported));
            break;

        case EVENT_CANNOT_ENUMERATE:
            MoveTo((GetMaxX() - GetTextWidth((XCHAR *) ErrMsgEnumerationStr, (void *) &FONTDEFAULT)) >> 1, yPos);
                    WAIT_UNTIL_FINISH(OutText((XCHAR *) ErrMsgEnumerationStr));
                    yPos += TextHeight;
                    MoveTo((GetMaxX() - GetTextWidth((XCHAR *) ErrMsgFailedStr, (void *) &FONTDEFAULT)) >> 1, yPos);
                    WAIT_UNTIL_FINISH(OutText((XCHAR *) ErrMsgFailedStr));
            break;

        case EVENT_CLIENT_INIT_ERROR:
            MoveTo((GetMaxX() - GetTextWidth((XCHAR *) ErrMsgClientInitStr, (void *) &FONTDEFAULT)) >> 1, yPos);
                    WAIT_UNTIL_FINISH(OutText((XCHAR *) ErrMsgClientInitStr));
                    yPos += TextHeight;
                    MoveTo((GetMaxX() - GetTextWidth((XCHAR *) ErrMsgFailedStr, (void *) &FONTDEFAULT)) >> 1, yPos);
                    WAIT_UNTIL_FINISH(OutText((XCHAR *) ErrMsgFailedStr));
            break;

        case EVENT_OUT_OF_MEMORY:
            MoveTo((GetMaxX() - GetTextWidth((XCHAR *) ErrMsgOutofMemoryStr, (void *) &FONTDEFAULT)) >> 1, yPos);
                    WAIT_UNTIL_FINISH(OutText((XCHAR *) ErrMsgOutofMemoryStr));
            break;

        case EVENT_UNSPECIFIED_ERROR:
            MoveTo((GetMaxX() - GetTextWidth((XCHAR *) ErrMsgUnpecifiedErrStr, (void *) &FONTDEFAULT)) >> 1, yPos);
                    WAIT_UNTIL_FINISH(OutText((XCHAR *) ErrMsgUnpecifiedErrStr));
            break;

        default:
            return (TRUE);
    }

    yPos += TextHeight;
            MoveTo((GetMaxX() - GetTextWidth((XCHAR *) MsgTouchToProceedStr, (void *) &FONTDEFAULT)) >> 1, yPos);
            WAIT_UNTIL_FINISH(OutText((XCHAR *) MsgTouchToProceedStr));

            // wait for touch
            while (!SCREEN_TOUCHED());

        return (TRUE);
    }
		]]>
                </Section>
                <Section Name="InitializeBoard" Option="chkUSBhost" Order="9">
<![CDATA[
    USBInitialize(0);
    SetColor(WHITE);
    ClearDevice();
    SetFont((void *) &FONTDEFAULT);
    SetColor(BLUE);
    const XCHAR strWaitUSB1[] = {'W', 'a', 'i', 't', 'i', 'n', 'g', ' ', 'f', 'o', 'r', ' ', 'U', 'S', 'B', ' ', 'd', 'r', 'i', 'v', 'e', 0};
    const XCHAR strWaitUSB2[] = {'M', 'o', 'u', 'n', 't', 'i', 'n', 'g', '.', '.', '.', 0};
    const XCHAR strWaitUSB3[] = {'M', 'o', 'u', 'n', 't', 'e', 'd', 0};
    UINT16 y=(GetMaxY() >> 1);
    MoveTo((GetMaxX() - GetTextWidth((XCHAR *) strWaitUSB1, (void *) &FONTDEFAULT)) >> 1, y - 12);
    WAIT_UNTIL_FINISH(OutText((XCHAR *) strWaitUSB1));
    DWORD tickPot = tick;
    while (!USBHostMSDSCSIMediaDetect() && !SCREEN_TOUCHED()) {
        if ((tick - tickPot) > 10000) { // Waits about 10 seconds for the USB media, then gives up: no PutImageFromSD. Also exits if screen touched
            break;
        }
        USBTasks();
    }
    if (USBHostMSDSCSIMediaDetect()) {
        MoveTo((GetMaxX() - GetTextWidth((XCHAR *) strWaitUSB2, (void *) &FONTDEFAULT)) >> 1, y + 12);
        WAIT_UNTIL_FINISH(OutText((XCHAR *) strWaitUSB2));
        while (!FileSystemInit());
        MoveTo((GetMaxX() - GetTextWidth((XCHAR *) strWaitUSB3, (void *) &FONTDEFAULT)) >> 1, y + 36);
        WAIT_UNTIL_FINISH(OutText((XCHAR *) strWaitUSB3));
        DelayMs(1000);
    }
]]>
                </Section>
                <Section Name="MainLoop" Option="chkUSBhost">
<![CDATA[
        USBTasks();
]]>
                </Section>
            </Code>
        </Group>
        <Group Name="PutImageFromSD">
            <Project>
                <Folder Name="Header Files/VGDD" Option="chkPutImageFromSD">
                    <AddVGDDFile>PutImageFromSD.h</AddVGDDFile>
                </Folder>
                <Folder Name="Source Files/VGDD" Option="chkPutImageFromSD">
                    <AddVGDDFile>PutImageFromSD.c</AddVGDDFile>
                </Folder>
            </Project>
            <Code>
                <Section Name="MainHeader" Option="!chkUSBhost,chkPutImageFromSD">
<![CDATA[
        #include "drv_spi.h"
]]>
                </Section>
                <Section Name="HardwareProfile" Option="chkPutImageFromSD">
<![CDATA[
#define USE_BITMAP_SD
#define SD_IMAGEDIR "\\img"
#include "PutImageFromSD.h"
#ifndef USE_USB_INTERFACE
    #define USE_SD_INTERFACE_WITH_SPI  // If USB support is not enabled, then use direct SPI attached SD socket
    #define SPI_START_CFG_1     (PRI_PRESCAL_64_1 | SEC_PRESCAL_8_1 | MASTER_ENABLE_ON | SPI_CKE_ON | SPI_SMP_ON)
    #define SPI_START_CFG_2     (SPI_ENABLE)
    #define SPI_FREQUENCY       (20000000)
#endif
]]>
                </Section>
            </Code>
        </Group>
        <Group Name="FlashProgrammer">
            <Project>
                <Folder Name="Source Files/Memory Programmer" Option="chkFlashProgrammer">
                    <AddFile>$MAL/../Graphics/Common/FlashProgrammer.c</AddFile>
                    <AddFile>$MAL/../Graphics/Common/comm_pkt.c</AddFile>
                    <AddFile>$MAL/../Graphics/Common/comm_pkt_callback.c</AddFile>
                    <AddVGDDFile>UART.c</AddVGDDFile>
                </Folder>
                <Folder Name="Header Files/Memory Programmer" Option="chkFlashProgrammer">
                    <AddFile>$MAL/../Graphics/Common/FlashProgrammer.h</AddFile>
                    <AddFile>$MAL/../Graphics/Common/ExternalMemory.h</AddFile>
                    <AddFile>$MAL/../Graphics/Common/comm_pkt.h</AddFile>
                    <AddFile>$MAL/../Graphics/Common/comm_pkt_callback.h</AddFile>
                    <AddVGDDFile>UART.h</AddVGDDFile>
                </Folder>
                <Folder Name="Source Files/USB" Option="chkFlashProgrammer">
                    <AddFile>$MAL/USB/usb_device.c</AddFile>
                </Folder>
                <Folder Name="Header Files" Option="chkFlashProgrammer">
                    <AddVGDDFile Modify="Yes" DestFile="usb_config.h">usb_config_MP.h</AddVGDDFile>
                </Folder>
                <Folder Name="Header Files/USB" Option="chkFlashProgrammer">
                    <AddFile>$MAL/USB/usb_device_local.h</AddFile>
                    <AddFile>$MAL/Include/USB/usb.h</AddFile>
                    <AddFile>$MAL/USB/usb_hal_local.h</AddFile>
                    <AddFile>$MAL/Include/USB/usb_common.h</AddFile>
                    <AddFile>$MAL/Include/USB/usb_ch9.h</AddFile>
                    <AddFile>$MAL/Include/USB/usb_device.h</AddFile>
                    <AddFile>$MAL/Include/USB/usb_hal.h</AddFile>
                </Folder>
                <Folder Name="Source Files" Option="chkFlashProgrammer">
                    <AddVGDDFile>usb_callback.c</AddVGDDFile>
                    <AddVGDDFile>usb_descriptors.c</AddVGDDFile>
                </Folder>
            </Project>
            <Code>
                <Section Name="HardwareProfile" Option="chkFlashProgrammer">
<![CDATA[
// --------------------------------------------          
// FlashProgrammer - Use USB
// --------------------------------------------          
#define USE_COMM_PKT_MEDIA_USB  // Comment out this line if you want to use USE_COMM_PKT_MEDIA_SERIAL_PORT below

#define COMM_PKT_RX_MAX_SIZE    (1024)

// --------------------------------------------          
// FlashProgrammer - Use UART
// --------------------------------------------          
//#define USE_COMM_PKT_MEDIA_SERIAL_PORT
#ifdef USE_COMM_PKT_MEDIA_SERIAL_PORT
#define BAUDRATE2               115200UL
#define BRG_DIV2                4
#define BRGH2                   1
#endif // USE_COMM_PKT_MEDIA_SERIAL_PORT
#ifndef TX_TRIS
// IOS FOR THE UART
#if defined(__dsPIC33FJ128GP804__) || defined(__PIC24HJ128GP504__)
    #define TX_TRIS TRISCbits.TRISC1
    #define RX_TRIS TRISCbits.TRISC0
#elif defined(__PIC24FJ256DA210__)    
    #define TX_TRIS TRISFbits.TRISF3
    #define RX_TRIS TRISDbits.TRISD0
#else
    #define TX_TRIS TRISFbits.TRISF5
    #define RX_TRIS TRISFbits.TRISF4
#endif
#endif // ndef TX_TRIS
// --------------------------------------------          

]]>
                </Section>
                <Section Name="Main" Option="chkFlashProgrammer">
<![CDATA[

// --------------------------------------------------------------------
// void CheckExternalFlashHex(void)
// --------------------------------------------------------------------
void CheckExternalFlashHex()
{
    typedef struct 
    {
        UINT32 mchpSignature;
        UINT32 mchpCRCData;
    } CRC_CHECK; 

    CRC_CHECK externalCRC, expectedCRC;   
    WORD textHeight;
    void *pFont;
    XCHAR *pStr = NULL;
    BOOL  setProgram = FALSE;
    
    XCHAR   msgStr1[] = {'P','r','o','g','r','a','m',' ','E','x','t','e','r','n','a','l',' ','D','a','t','a',0};
    XCHAR   msgStr2[] = {'E','x','t','e','r','n','a','l',' ','d','a','t','a',' ','i','n','v','a','l','i','d','.',0};
    XCHAR   msgStr3[] = {'P','l','e','a','s','e',' ','s','e','n','d',' ','d','a','t','a',' ','u','s','i','n','g',0};
    XCHAR   msgStr4[] = {'"','E','x','t','e','r','n','a','l',' ','M','e','m','o','r','y',0};
    XCHAR   msgStr5[] = {'P','r','o','g','r','a','m','m','e','r','"',' ','u','t','i','l','i','t','y',0};
    XCHAR   msgStr6[] = {'N','o','w',' ','w','a','i','t','i','n','g',' ','f','o','r',' ','d','a','t','a',0};
#ifdef USE_COMM_PKT_MEDIA_USB
    XCHAR   msgStr7[] = {'v','i','a',' ','U','S','B','.','.','.',0};
#else
    XCHAR   msgStr7[] = {'v','i','a',' ','U','A','R','T','.','.','.',0};
#endif

    pFont = (void*) &FONTDEFAULT;
    SetFont(pFont);
    textHeight = GetTextHeight(pFont);

    // check if the CRC matches the data stored in the external flash memory
    expectedCRC.mchpCRCData = GRC_CRC32_EXTERNAL_MARKER;
    expectedCRC.mchpSignature = 0x5048434D;                // this is "MCHP"

#ifndef GFX_PICTAIL_LCC
    // check if programming is prompted     
    if(GetHWButtonProgram() == HW_BUTTON_PRESS)
    {
        pStr = msgStr1;
        setProgram = TRUE;
    } 
#endif
    
    if (setProgram == FALSE)
    {
        ReadArray(GRC_CRC32_EXTERNAL_ADDR, (BYTE *)&externalCRC, 8);
    
        if  ((expectedCRC.mchpCRCData != externalCRC.mchpCRCData) || \
             (expectedCRC.mchpSignature != externalCRC.mchpSignature))
        {
            // expected and read CRC does not match, proceed to programming flash first
            // run the flash programming 
            pStr = msgStr2;
            setProgram = TRUE;
        }
    }
    
    if (setProgram == TRUE)
    {
        SetColor(BLACK);
        ClearDevice();
        SetColor(WHITE);
        OutTextXY(10,10                 , pStr);
        OutTextXY(10,10 + (textHeight*2), msgStr3);
        OutTextXY(10,10 + (textHeight*3), msgStr4);
        OutTextXY(10,10 + (textHeight*4), msgStr5);
        OutTextXY(10,10 + (textHeight*5), msgStr6);
        OutTextXY(10,10 + (textHeight*6), msgStr7);

        // Call the external flash programming routine
        ProgramFlash();
        DelayMs(100);

#if defined (USE_COMM_PKT_MEDIA_USB)

        // check if USB has sent reply to host then do a detach
        while(USBHandleBusy(USBGenericInHandle));
        USBDeviceDetach();
        // delay the reset to have time for the acknowledge data to be sent to the host side
        DelayMs(100);

#elif defined (USE_COMM_PKT_MEDIA_SERIAL_PORT)

        // check if UART is still busy sending replies to the host
        while(U2STAbits.TRMT);
        // delay the reset to have time for the acknowledge data to be sent to the host side
        DelayMs(10);

#endif
        SetColor(BLACK);
        ClearDevice();
        SetColor(WHITE);
        OutTextXY(10,10, "Flashing OK. Restarting...");
        DelayMs(2000);
        // Force Reset to force the checking of the flash memory if programming was a success
        Reset();
    }    
}	

/*********************************************************************
* Function: WORD ExternalMemoryCallback(EXTDATA* memory, LONG offset, WORD nCount, void* buffer)
*
* PreCondition: none
*
* Input:  memory - pointer to the bitmap or font external memory structures
*                  (FONT_EXTERNAL or BITMAP_EXTERNAL)
*         offset - data offset
*         nCount - number of bytes to be transferred to the buffer
*         buffer - pointer to the buffer
*
* Output: number of bytes were transferred.
*
* Side Effects: none
*
* Overview: this function must be implemented in application. Graphics Library calls it
*           each time the data from external memory is required. The application must copy 
*           required data to the buffer provided.
*
* Note: none
*
********************************************************************/
// If there are several memories in the system they can be selected by IDs.
// In this demo ID for memory chip installed on Graphics PICTail board is assumed to be 0.
#define SST39_MEMORY    0
/* */

WORD ExternalMemoryCallback(IMAGE_EXTERNAL *memory, LONG offset, WORD nCount, void *buffer)
{
    if(memory->ID == SST39_MEMORY)
    {

        // Read data requested into buffer provided
        SST25ReadArray(memory->address + offset, // address to read from
        (BYTE *)buffer, nCount);
    }

    return (nCount);
}
]]>
                </Section>
                <Section Name="MainHead" Option="chkFlashProgrammer">
<![CDATA[
#if defined (USE_COMM_PKT_MEDIA_USB)
    extern USB_HANDLE USBGenericInHandle;
#endif
void CheckExternalFlashHex();
]]>
                </Section>
                <Section Name="InitializeBoard" Option="chkFlashProgrammer" Order="4">
<![CDATA[
	// Programming the flash is not possible when using the PIC32 STK since the hardware 
    // does not support it (no serial port) so we skip this check if using the STKs
    #if defined (EXPLORER_16) || defined (PIC24FJ256DA210_DEV_BOARD)
        /**
         * Force a flash chip program
         * Explorer 16 + GFX PICTail    - S3 (8 bit PMP)
         * Explorer 16 + GFX PICTail    - S5 (16 bit PMP)
         * DA210 Developement Board     - S1
         **/
	    if(GetHWButtonProgram() == HW_BUTTON_PRESS) {
				ProgramFlash();
	    }
	#endif	//defined (EXPLORER_16) || defined (PIC24FJ256DA210_DEV_BOARD)
		]]>
                </Section>
                <Section Name="MainHeader" Option="chkFlashProgrammer">
<![CDATA[
#include "FlashProgrammer.h"
#include "ExternalMemory.h"
#if defined (USE_COMM_PKT_MEDIA_USB)
    #include "USB/usb.h"
    #include "USB/usb_function_generic.h"
#endif
]]>
                </Section>
            </Code>
        </Group>
        <Group Name="DEEEmulation">
            <Project>
                <ClearFolder Name="Source Files/DEE Emulation" />
                <ClearFolder Name="Header Files/DEE Emulation" />
                <Folder Name="Header Files/DEE Emulation" Option="chkDEE" Family="PIC32">
                    <AddVGDDFile>dee_emulation_pic32.h</AddVGDDFile>
                </Folder>
                <Folder Name="Source Files/DEE Emulation" Option="chkDEE" Family="PIC32">
                    <AddVGDDFile>dee_emulation_pic32.c</AddVGDDFile>
                </Folder>
                <Folder Name="Header Files/DEE Emulation" Option="chkDEE" Family="PIC24">
                    <AddVGDDFile>DEE_Emulation_16-bit.h</AddVGDDFile>
                </Folder>
                <Folder Name="Source Files/DEE Emulation" Option="chkDEE" Family="PIC24">
                    <AddVGDDFile>DEE_Emulation_16-bit.c</AddVGDDFile>
                    <AddVGDDFile>FlashOperations_16-bit.S</AddVGDDFile>
                </Folder>
            </Project>
            <Code>
                <Section Name="InitializeBoard" Option="chkDEE" Order="1">
<![CDATA[
    if(DataEEInit()!=0){
        ErrorTrap("Cannot initialize DEE Emu");
    }    
]]>
                </Section>
                <Section Name="MainHeader" Option="chkDEE" Family="PIC32">
<![CDATA[
#include "dee_emulation_pic32.h"
WORD TouchNVMRead(DWORD address);
void TouchNVMWrite(WORD data, DWORD address);
]]>
                </Section>
                <Section Name="MainHeader" Option="chkDEE" Family="PIC24">
<![CDATA[
#include "DEE_Emulation_16-bit.h"
WORD TouchNVMRead(DWORD address);
void TouchNVMWrite(WORD data, DWORD address);
]]>
                </Section>
                <Section Name="Main" Option="chkDEE" Family="PIC32">
<![CDATA[
WORD TouchNVMRead(DWORD address) {
    unsigned int data;
    if(DataEERead(&data,(unsigned int)address)!=0)
        return(0);
    return data;
}

void TouchNVMWrite(WORD data, DWORD address) {
    if(DataEEWrite(data,address)!=0){
        ErrorTrap("Cannot write DEE Emu");
    }    
}
]]>
                </Section>
                <Section Name="Main" Option="chkDEE" Family="PIC24">
<![CDATA[
WORD TouchNVMRead(DWORD address) {
    return DataEERead((unsigned int)address);
}

void TouchNVMWrite(WORD data, DWORD address) {
    if(DataEEWrite(data,address)!=0){
        ErrorTrap("Cannot write DEE Emu");
    }    
}
]]>
                </Section>
                <Section Name="HardwareProfile" Option="chkDEE,chkTCPIP">
<![CDATA[
#define USE_DEE_EMU // Data Eeprom Emulation (DEE) support 
]]>
                </Section>
                <Section Name="HardwareProfile" Option="chkDEE,chkTCPIP">
<![CDATA[
// --------------------------------------------------------------------
// Data Eeprom Emulation (DEE) support Macros
// --------------------------------------------------------------------
#define ADDRESS_TCPIP_APP_VERSION (unsigned long)0x12
]]>
                </Section>
                <Section Name="HardwareProfile" Option="chkDEE">
<![CDATA[
// --------------------------------------------------------------------
// Touch Screen Non-Volatile Memory Storage Macros for Data Eeprom Emulation (DEE)
// --------------------------------------------------------------------
#define ADDRESS_RESISTIVE_TOUCH_VERSION (unsigned long)0x00
#define ADDRESS_RESISTIVE_TOUCH_ULX     (unsigned long)0x02
#define ADDRESS_RESISTIVE_TOUCH_ULY     (unsigned long)0x04
#define ADDRESS_RESISTIVE_TOUCH_URX     (unsigned long)0x06
#define ADDRESS_RESISTIVE_TOUCH_URY     (unsigned long)0x08

#define ADDRESS_RESISTIVE_TOUCH_LLX     (unsigned long)0x0a
#define ADDRESS_RESISTIVE_TOUCH_LLY     (unsigned long)0x0c
#define ADDRESS_RESISTIVE_TOUCH_LRX     (unsigned long)0x0e
#define ADDRESS_RESISTIVE_TOUCH_LRY     (unsigned long)0x10

#define NVMSectorErase                  (NULL)
#define NVMWrite                        (TouchNVMWrite)
#define NVMRead                         (TouchNVMRead)

]]>
                </Section>
            </Code>
        </Group>
        <Group Name="DS18B20">
            <Project>
                <Folder Name="Header Files/Board Support Package" Option="chkDS18B20">
                    <AddVGDDFile>ds1820.h</AddVGDDFile>
                </Folder>
                <Folder Name="Source Files/Board Support Package" Option="chkDS18B20">
                    <AddVGDDFile>ds1820.c</AddVGDDFile>
                </Folder>
            </Project>
            <Code>
                <Section Name="HardwareProfile" Option="chkDS18B20">
<![CDATA[
// --------------------------------------------------------------------
// IOS FOR DS18B20 1-Wire thermometer
// --------------------------------------------------------------------
#define DS1820_DATAPIN_OUT  _LATD1
#define DS1820_DATAPIN_IN   _RD1
#define DS1820_DATATRIS     _TRISD1
#define DS1820_POWERTRIS    _TRISD11
#define DS1820_POWER        _LATD11
#define NUM_DS1820 1    // Number of DS18B20 chips to be read
]]>
                </Section>
                <Section Name="MainHeader" Option="chkDS18B20">
<![CDATA[
#include "ds1820.h"
]]>
                </Section>
                <Section Name="MainHead" Option="chkDS18B20">
<![CDATA[
XCHAR strTemperatureString[9];   // Buffer for temperature string from DS18B20
]]>
                </Section>
                <Section Name="MainHeader" Option="chkDS18B20">
<![CDATA[
extern XCHAR strTemperatureString[];   // Buffer for temperature string from DS18B20
]]>
                </Section>
                <Section Name="MainBeforeLoop" Option="chkDS18B20">
<![CDATA[
    // --------------------------------------------------------------------
    // Search DS18B20s on 1-Wire bus
    // --------------------------------------------------------------------
    DS1820Found = 0;
    DS1820_POWER = 1;
    DS1820_POWERTRIS = 0;
    DelayMs(10);
    DS1820_DATATRIS = 1;
    if (DS1820_DATAPIN_IN != 0) { // It goes high if pullup resistor is present
        DS1820Selected = 0;
        if (DS1820_FindFirstDevice()) {
            DS1820Selected++;
            while (DS1820_FindNextDevice()) {
                DS1820Selected++;
            }
        }
    }
    DS1820_POWER = 0;
]]>
                </Section>
                <Section Name="MainLoop" Option="chkDS18B20">
<![CDATA[
        // --------------------------------------------------------------------
        // Read DS18B20s on 1-Wire bus
        // --------------------------------------------------------------------
        static DWORD TickTemperatureStart, TickTemperatureSampling;
        if (TickTemperatureSampling == 0 && (tick - TickTemperatureStart > 4000)) {
            TickTemperatureStart = tick;
            DS1820_POWER = 1;
            DS1820_POWERTRIS = 0;
            DelayMs(10);
            for (DS1820Selected = 0; DS1820Selected < DS1820Found; DS1820Selected++) {
                DS1820_StartConversion();
            }
            TickTemperatureSampling = tick;
        } else if (TickTemperatureSampling != 0 && (tick - TickTemperatureSampling > 4000)) {
            TickTemperatureSampling = 0;
            DS1820_GetAllTemps();
            DS1820_GetTempString(DS1820LastTemp[0], strTemperatureString);
            DS1820_POWER = 0;
        }
]]>
                </Section>
            </Code>
        </Group>
        <Group Name="TcpIp">
            <Project>
                <Folder Name="Source Files/TCPIP Stack" Option="chkTCPIP">
                    <AddFile>$MAL/TCPIP Stack/Announce.c</AddFile>
                    <AddFile>$MAL/TCPIP Stack/ARP.c</AddFile>
                    <AddFile>$MAL/TCPIP Stack/AutoIP.c</AddFile>
                    <AddFile>$MAL/TCPIP Stack/BerkeleyAPI.c</AddFile>
                    <AddFile Override="optimization-level=">$MAL/TCPIP Stack/Delay.c</AddFile>
                    <AddFile>$MAL/TCPIP Stack/DHCP.c</AddFile>
                    <AddFile>$MAL/TCPIP Stack/DNS.c</AddFile>
                    <AddFile>$MAL/TCPIP Stack/ETHPIC32IntMac.c</AddFile>
                    <AddFile>$MAL/TCPIP Stack/Hashes.c</AddFile>
                    <AddFile>$MAL/TCPIP Stack/Helpers.c</AddFile>
                    <AddFile>$MAL/TCPIP Stack/ICMP.c</AddFile>
                    <AddFile>$MAL/TCPIP Stack/IP.c</AddFile>
                    <AddFile>$MAL/TCPIP Stack/LCDBlocking.c</AddFile>
                    <AddFile>$MAL/TCPIP Stack/NBNS.c</AddFile>
                    <AddFile>$MAL/TCPIP Stack/Random.c</AddFile>
                    <AddFile>$MAL/TCPIP Stack/Reboot.c</AddFile>
                    <AddFile>$MAL/TCPIP Stack/RSA.c</AddFile>
                    <AddFile>$MAL/TCPIP Stack/SMTP.c</AddFile>
                    <AddFile>$MAL/TCPIP Stack/SNMP.c</AddFile>
                    <AddFile>$MAL/TCPIP Stack/SNMPv3.c</AddFile>
                    <AddFile>$MAL/TCPIP Stack/SPIEEPROM.c</AddFile>
                    <AddFile>$MAL/TCPIP Stack/SPIFlash.c</AddFile>
                    <AddFile>$MAL/TCPIP Stack/SPIRAM.c</AddFile>
                    <AddFile>$MAL/TCPIP Stack/SSL.c</AddFile>
                    <AddFile>$MAL/TCPIP Stack/StackTsk.c</AddFile>
                    <AddFile>$MAL/TCPIP Stack/TCP.c</AddFile>
                    <AddFile>$MAL/TCPIP Stack/TCPPerformanceTest.c</AddFile>
                    <AddFile>$MAL/TCPIP Stack/Telnet.c</AddFile>
                    <AddFile>$MAL/TCPIP Stack/TFTPc.c</AddFile>
                    <AddFile>$MAL/TCPIP Stack/Tick.c</AddFile>
                    <AddFile>$MAL/TCPIP Stack/UART.c</AddFile>
                    <AddFile>$MAL/TCPIP Stack/UART2TCPBridge.c</AddFile>
                    <AddFile>$MAL/TCPIP Stack/UDP.c</AddFile>
                    <AddFile>$MAL/TCPIP Stack/UDPPerformanceTest.c</AddFile>
                    <AddFile>$MAL/TCPIP Stack/ZeroconfHelper.c</AddFile>
                    <AddFile>$MAL/TCPIP Stack/ZeroconfLinkLocal.c</AddFile>
                    <AddFile>$MAL/TCPIP Stack/ZeroconfMulticastDNS.c</AddFile>
                </Folder>
                <Folder Name="Header Files/TCPIP Stack" Option="chkTCPIP">
                    <AddFile>$MAL/Include/TCPIP Stack/ZeroconfMulticastDNS.h</AddFile>
                    <AddFile>$MAL/Include/TCPIP Stack/ZeroconfLinkLocal.h</AddFile>
                    <AddFile>$MAL/Include/TCPIP Stack/ZeroconfHelper.h</AddFile>
                    <AddFile>$MAL/Include/TCPIP Stack/XEEPROM.h</AddFile>
                    <AddFile>$MAL/Include/TCPIP Stack/UDPPerformanceTest.h</AddFile>
                    <AddFile>$MAL/Include/TCPIP Stack/UDP.h</AddFile>
                    <AddFile>$MAL/Include/TCPIP Stack/UART2TCPBridge.h</AddFile>
                    <AddFile>$MAL/Include/TCPIP Stack/UART.h</AddFile>
                    <AddFile>$MAL/Include/TCPIP Stack/Tick.h</AddFile>
                    <AddFile>$MAL/Include/TCPIP Stack/TFTPc.h</AddFile>
                    <AddFile>$MAL/Include/TCPIP Stack/Telnet.h</AddFile>
                    <AddFile>$MAL/Include/TCPIP Stack/TCPPerformanceTest.h</AddFile>
                    <AddFile>$MAL/Include/TCPIP Stack/TCPIP.h</AddFile>
                    <AddFile>$MAL/Include/TCPIP Stack/TCP.h</AddFile>
                    <AddFile>$MAL/Include/TCPIP Stack/StackTsk.h</AddFile>
                    <AddFile>$MAL/Include/TCPIP Stack/SSLClientSize.h</AddFile>
                    <AddFile>$MAL/Include/TCPIP Stack/SSL.h</AddFile>
                    <AddFile>$MAL/Include/TCPIP Stack/SPIRAM.h</AddFile>
                    <AddFile>$MAL/Include/TCPIP Stack/SPIFlash.h</AddFile>
                    <AddFile>$MAL/Include/TCPIP Stack/SNTP.h</AddFile>
                    <AddFile>$MAL/Include/TCPIP Stack/SNMPv3.h</AddFile>
                    <AddFile>$MAL/Include/TCPIP Stack/SNMP.h</AddFile>
                    <AddFile>$MAL/Include/TCPIP Stack/SMTP.h</AddFile>
                    <AddFile>$MAL/Include/TCPIP Stack/RSA.h</AddFile>
                    <AddFile>$MAL/Include/TCPIP Stack/regdef.h</AddFile>
                    <AddFile>$MAL/Include/TCPIP Stack/Reboot.h</AddFile>
                    <AddFile>$MAL/Include/TCPIP Stack/Random.h</AddFile>
                    <AddFile>$MAL/Include/TCPIP Stack/NBNS.h</AddFile>
                    <AddFile>$MAL/Include/TCPIP Stack/MAC.h</AddFile>
                    <AddFile>$MAL/Include/TCPIP Stack/LCDBlocking.h</AddFile>
                    <AddFile>$MAL/Include/TCPIP Stack/IP.h</AddFile>
                    <AddFile>$MAL/Include/TCPIP Stack/ICMP.h</AddFile>
                    <AddFile>$MAL/Include/TCPIP Stack/Helpers.h</AddFile>
                    <AddFile>$MAL/Include/TCPIP Stack/Hashes.h</AddFile>
                    <AddFile>$MAL/Include/TCPIP Stack/FTP.h</AddFile>
                    <AddFile>$MAL/Include/TCPIP Stack/FileSystem.h</AddFile>
                    <AddFile>$MAL/Include/TCPIP Stack/ETHPIC32ExtPhySMSC8720.h</AddFile>
                    <AddFile>$MAL/Include/TCPIP Stack/ETHPIC32ExtPhySMSC8700.h</AddFile>
                    <AddFile>$MAL/Include/TCPIP Stack/ETHPIC32ExtPhyRegs.h</AddFile>
                    <AddFile>$MAL/Include/TCPIP Stack/ETHPIC32ExtPhyDP83848.h</AddFile>
                    <AddFile>$MAL/Include/TCPIP Stack/ETHPIC32ExtPhyDP83640.h</AddFile>
                    <AddFile>$MAL/Include/TCPIP Stack/ETHPIC32ExtPhy.h</AddFile>
                    <!--<AddFile>$MAL/Include/TCPIP Stack/eth_pic32_ext_phy_rtl8201FL.h</AddFile>-->
                    <AddFile>$MAL/Include/TCPIP Stack/ETH97J60.h</AddFile>
                    <AddFile>$MAL/Include/TCPIP Stack/ENCX24J600.h</AddFile>
                    <AddFile>$MAL/Include/TCPIP Stack/ENC28J60.h</AddFile>
                    <AddFile>$MAL/Include/TCPIP Stack/DynDNS.h</AddFile>
                    <AddFile>$MAL/Include/TCPIP Stack/DNS.h</AddFile>
                    <AddFile>$MAL/Include/TCPIP Stack/DHCP.h</AddFile>
                    <AddFile>$MAL/Include/TCPIP Stack/Delay.h</AddFile>
                    <AddFile>$MAL/Include/TCPIP Stack/BigInt.h</AddFile>
                    <AddFile>$MAL/Include/TCPIP Stack/BerkeleyAPI.h</AddFile>
                    <AddFile>$MAL/Include/TCPIP Stack/AutoIP.h</AddFile>
                    <AddFile>$MAL/Include/TCPIP Stack/ARP.h</AddFile>
                    <AddFile>$MAL/Include/TCPIP Stack/ARCFOUR.h</AddFile>
                    <AddFile>$MAL/Include/TCPIP Stack/Announce.h</AddFile>
                </Folder>
                <Folder Name="Header Files/TCPIP Stack/WiFi" Option="chkWiFi">
                    <AddFile>$MAL/Include/TCPIP Stack/aes_pic24f.h</AddFile>
                    <AddFile>$MAL/Include/TCPIP Stack/AES_OFB.h</AddFile>
                    <AddFile>$MAL/Include/TCPIP Stack/AES_ECB_PIC32.h</AddFile>
                    <AddFile>$MAL/Include/TCPIP Stack/AES_ECB.h</AddFile>
                    <AddFile>$MAL/Include/TCPIP Stack/AES_CTR.h</AddFile>
                    <AddFile>$MAL/Include/TCPIP Stack/AES_CFB.h</AddFile>
                    <AddFile>$MAL/Include/TCPIP Stack/AES_CBC.h</AddFile>
                    <AddFile>$MAL/Include/TCPIP Stack/AES.h</AddFile>
                    <AddFile>$MAL/Include/TCPIP Stack/WFRaw_24G.h</AddFile>
                    <AddFile>$MAL/Include/TCPIP Stack/WFRaw.h</AddFile>
                    <AddFile>$MAL/Include/TCPIP Stack/WFMgmtMsg.h</AddFile>
                    <AddFile>$MAL/Include/TCPIP Stack/WFMac.h</AddFile>
                    <AddFile>$MAL/Include/TCPIP Stack/WFEasyConfig.h</AddFile>
                    <AddFile>$MAL/Include/TCPIP Stack/WFDriverPrv_24G.h</AddFile>
                    <AddFile>$MAL/Include/TCPIP Stack/WFDriverPrv.h</AddFile>
                    <AddFile>$MAL/Include/TCPIP Stack/WFDebugStrings.h</AddFile>
                    <AddFile>$MAL/Include/TCPIP Stack/WFConsoleMsgs.h</AddFile>
                    <AddFile>$MAL/Include/TCPIP Stack/WFConsoleMsgHandler.h</AddFile>
                    <AddFile>$MAL/Include/TCPIP Stack/WFConsoleIwpriv.h</AddFile>
                    <AddFile>$MAL/Include/TCPIP Stack/WFConsoleIwconfig.h</AddFile>
                    <AddFile>$MAL/Include/TCPIP Stack/WFConsoleIfconfig.h</AddFile>
                    <AddFile>$MAL/Include/TCPIP Stack/WFConsole.h</AddFile>
                    <AddFile>$MAL/Include/TCPIP Stack/WFApi.h</AddFile>
                    <AddFile>$MAL/Include/TCPIP Stack/WF_pbkdf2.h</AddFile>
                </Folder>
                <Folder Name="Source Files/TCPIP App" Option="chkTCPIP">
                    <AddVGDDFile>CustomHTTPApp.c</AddVGDDFile>
                    <AddVGDDFile>GenericTCPServer.c</AddVGDDFile>
                    <AddVGDDFile>TCPIPConfig.h</AddVGDDFile>
                    <AddVGDDFile>SNTP.c</AddVGDDFile>
                    <AddVGDDFile>HTTPPrint.h</AddVGDDFile>
                    <AddVGDDFile DestDir="TCPIP Stack">TCPIP.h</AddVGDDFile>
                    <AddVGDDFile DestDir="TCPIP Stack">StackTsk.h</AddVGDDFile>
                </Folder>
                <Folder Name="Source Files/TCPIP App" Option="chkMPFS,chkTCPIP">
                    <AddFile>$MAL/TCPIP Stack/HTTP2.c</AddFile>
                    <AddFile>$MAL/TCPIP Stack/MPFS2.c</AddFile>
                    <AddVGDDFile>MPFSImg2.c</AddVGDDFile>
                    <AddVGDDFile>FSconfig.h</AddVGDDFile>
                    <RemoveFile>HTTP2_MDD.c</RemoveFile>
                    <RemoveFile>_HTTP2.h</RemoveFile>
                    <EnableDisableDefine File="TCPIPConfig.h">
                        <Disable>STACK_USE_MDD</Disable>
                        <Disable>STACK_USE_MPFS</Disable>
                        <Enable>STACK_USE_MPFS2</Enable>
                        <Disable>STACK_USE_FATFS</Disable>
                    </EnableDisableDefine>
                </Folder>
                <Folder Name="Source Files/TCPIP App" Option="chkFatFs,chkTCPIP">
                    <AddVGDDFile>HTTP2_MDD.c</AddVGDDFile>
                    <AddVGDDFile DestDir="TCPIP Stack">_HTTP2.h</AddVGDDFile>
                    <AddVGDDFile>FSconfig.h</AddVGDDFile>
                    <RemoveFile>HTTP2.c</RemoveFile>
                    <RemoveFile>MPFSImg2.c</RemoveFile>
                    <EnableDisableDefine File="TCPIPConfig.h">
                        <Disable>STACK_USE_MDD</Disable>
                        <Disable>STACK_USE_MPFS</Disable>
                        <Disable>STACK_USE_MPFS2</Disable>
                        <Enable>STACK_USE_FATFS</Enable>
                    </EnableDisableDefine>
                </Folder>
                <Folder Name="Source Files/TCPIP App" Option="chkFSIO,chkTCPIP">
                    <AddVGDDFile>HTTP2_MDD.c</AddVGDDFile>
                    <AddVGDDFile DestDir="TCPIP Stack">_HTTP2.h</AddVGDDFile>
                    <AddVGDDFile>FSconfig.h</AddVGDDFile>
                    <RemoveFile>HTTP2.c</RemoveFile>
                    <RemoveFile>MPFSImg2.c</RemoveFile>
                    <EnableDisableDefine File="TCPIPConfig.h">
                        <Enable>STACK_USE_MDD</Enable>
                        <Disable>STACK_USE_MPFS</Disable>
                        <Disable>STACK_USE_MPFS2</Disable>
                        <Disable>STACK_USE_FATFS</Disable>
                    </EnableDisableDefine>
                </Folder>
                <Folder Name="ExternalFiles" Option="chkTCPIP">
                    <AddVGDDFile DestDir="WebPages/protect">upload.htm</AddVGDDFile>
                    <AddVGDDFile DestDir="WebPages/protect">auth.htm</AddVGDDFile>
                    <AddVGDDFile DestDir="WebPages/protect">reboot.cgi</AddVGDDFile>
                    <AddVGDDFile DestDir="WebPages/protect">reboot.htm</AddVGDDFile>
                    <AddVGDDFile DestDir="WebPages/protect">config.htm</AddVGDDFile>
                    <AddVGDDFile DestDir="WebPages/protect" DestFile="index.htm">protect_index.htm</AddVGDDFile>
                    <AddVGDDFile DestDir="WebPages">noupload.htm</AddVGDDFile>
                    <AddVGDDFile DestDir="WebPages">cookies.htm</AddVGDDFile>
                    <AddVGDDFile DestDir="WebPages">dynvars.htm</AddVGDDFile>
                    <AddVGDDFile DestDir="WebPages">footer.inc</AddVGDDFile>
                    <AddVGDDFile DestDir="WebPages">forms.htm</AddVGDDFile>
                    <AddVGDDFile DestDir="WebPages">header.inc</AddVGDDFile>
                    <AddVGDDFile DestDir="WebPages">index.htm</AddVGDDFile>
                    <AddVGDDFile DestDir="WebPages">leds.cgi</AddVGDDFile>
                    <AddVGDDFile DestDir="WebPages">mchp.css</AddVGDDFile>
                    <AddVGDDFile DestDir="WebPages">mchp.gif</AddVGDDFile>
                    <AddVGDDFile DestDir="WebPages">mchp.js</AddVGDDFile>
                    <AddVGDDFile DestDir="WebPages">snmp.bib</AddVGDDFile>
                    <AddVGDDFile DestDir="WebPages">status.xml</AddVGDDFile>
                    <AddVGDDFile DestDir="WebPages">temp.cgi</AddVGDDFile>
                    <AddVGDDFile DestDir="WebPages">virtfab.png</AddVGDDFile>
                </Folder>
                <Folder Name="" Option="chkTCPIP">
                    <RemoveFile>TimeDelay.c</RemoveFile>
                </Folder>
            </Project>
            <Code>
                <Section Name="InitializeBoard" Option="chkTCPIP" Order="8">
<![CDATA[
    TickInit();                  // initialize the timer that manages the tick counter for TCP/IP stack
]]>
                </Section>
                <Section Name="MainHeader" Option="chkTCPIP">
<![CDATA[
#include "TCPIP Stack/TCPIP.h"
extern WORD intTemperature;
extern BYTE LedState[];    // Stores virtual LEDs state
]]>
                </Section>
                <Section Name="MainHead" Option="chkTCPIP">
<![CDATA[
// Declare AppConfig structure and some other supporting stack variables
APP_CONFIG AppConfig;
BYTE AN0String[8];
WORD intTemperature;
BYTE LedState[4];    // Stores virtual LEDs state

// Private helper functions.
static void InitAppConfig(void);
static void ProcessIO(void);

// Public helper functions.
void SaveAppConfig(const APP_CONFIG *ptrAppConfig);
]]>
                </Section>
                <Section Name="MainBeforeLoop" Option="chkTCPIP">
<![CDATA[
    static DWORD dwLastIP = 0;

    // Initialize Stack and application related NV variables into AppConfig.
    InitAppConfig();

    // Initialize core stack layers (MAC, ARP, TCP, UDP) and
    // application modules (HTTP, SNMP, etc.)
    StackInit();

    TouchHardwareInit(NULL);	// Confirm ADC config so if stack initialization has scrambled the ADC config, touchscreen can work fine
]]>
                </Section>
                <Section Name="MainBeforeLoop" Option="chkMPFS">
<![CDATA[
    MPFSInit();
]]>
                </Section>
                <Section Name="MainLoop" Option="chkTCPIP">
<![CDATA[
        // This task performs normal stack task including checking
        // for incoming packet, type of packet and calling
        // appropriate stack entity to process it.
        StackTask();

        // This tasks invokes each of the core stack application tasks
        StackApplications();

#if defined(STACK_USE_ZEROCONF_LINK_LOCAL)
        ZeroconfLLProcess();
#endif

#if defined(STACK_USE_ZEROCONF_MDNS_SD)
        mDNSProcess();
        // Use this function to exercise service update function
        // HTTPUpdateRecord();
#endif

        // Process application specific tasks here.
        // For this demo app, this will include the Generic TCP
        // client and servers, and the SNMP, Ping, and SNMP Trap
        // demos.  Following that, we will process any IO from
        // the inputs on the board itself.
        // Any custom modules or processing you need to do should
        // go here.
#if defined(STACK_USE_GENERIC_TCP_CLIENT_EXAMPLE)
        GenericTCPClient();
#endif

#if defined(STACK_USE_GENERIC_TCP_SERVER_EXAMPLE)
        GenericTCPServer();
#endif

#if defined(STACK_USE_SMTP_CLIENT)
        SMTPDemo();
#endif

#if defined(STACK_USE_ICMP_CLIENT)
        PingDemo();
#endif

#if defined(STACK_USE_SNMP_SERVER) && !defined(SNMP_TRAP_DISABLED)
        //User should use one of the following SNMP demo
        // This routine demonstrates V1 or V2 trap formats with one variable binding.
        SNMPTrapDemo();
    #if defined(SNMP_STACK_USE_V2_TRAP)
        //This routine provides V2 format notifications with multiple (3) variable bindings
        //User should modify this routine to send v2 trap format notifications with the required varbinds.
        //SNMPV2TrapDemo();
    #endif
        if (gSendTrapFlag)
            SNMPSendTrap();
#endif

#if defined(STACK_USE_BERKELEY_API)
        BerkeleyTCPClientDemo();
        BerkeleyTCPServerDemo();
        BerkeleyUDPClientDemo();
#endif

        //ProcessIO();

        // If the local IP address has changed (ex: due to DHCP lease change)
        // write the new IP address to the LCD display, UART, and Announce
        // service
        if (dwLastIP != AppConfig.MyIPAddr.Val) {
            dwLastIP = AppConfig.MyIPAddr.Val;
#if defined(STACK_USE_UART)
            putrsUART((ROM char*) "\r\nNew IP Address: ");
#endif
            //DisplayIPValue(AppConfig.MyIPAddr); // Replace with your display IP routine
            TFTShowMyIp();
#if defined(STACK_USE_UART)
            putrsUART((ROM char*) "\r\n");
#endif
#if defined(STACK_USE_ANNOUNCE)
            AnnounceIP();
#endif
#if defined(STACK_USE_ZEROCONF_MDNS_SD)
            mDNSFillHostRecord();
#endif
		}
]]>
                </Section>
                <Section Name="Main" Option="chkTCPIP">
<![CDATA[
/*********************************************************************
 * Function:        void InitAppConfig(void)
 *
 * PreCondition:    MPFSInit() is already called.
 *
 * Input:           None
 *
 * Output:          Write/Read non-volatile config variables.
 *
 * Side Effects:    None
 *
 * Overview:        None
 *
 * Note:            None
 ********************************************************************/
// MAC Address Serialization using a MPLAB PM3 Programmer and
// Serialized Quick Turn Programming (SQTP).
// The advantage of using SQTP for programming the MAC Address is it
// allows you to auto-increment the MAC address without recompiling
// the code for each unit.  To use SQTP, the MAC address must be fixed
// at a specific location in program memory.  Uncomment these two pragmas
// that locate the MAC address at 0x1FFF0.  Syntax below is for MPLAB C
// Compiler for PIC18 MCUs. Syntax will vary for other compilers.
//#pragma romdata MACROM=0x1FFF0
static ROM BYTE SerializedMACAddress[6] = {MY_DEFAULT_MAC_BYTE1, MY_DEFAULT_MAC_BYTE2, MY_DEFAULT_MAC_BYTE3, MY_DEFAULT_MAC_BYTE4, MY_DEFAULT_MAC_BYTE5, MY_DEFAULT_MAC_BYTE6};
//#pragma romdata

static void InitAppConfig(void) {
    AppConfig.Flags.bIsDHCPEnabled = TRUE;
    AppConfig.Flags.bInConfigMode = TRUE;
    memcpypgm2ram((void*) &AppConfig.MyMACAddr, (ROM void*) SerializedMACAddress, sizeof (AppConfig.MyMACAddr));
    //   {
    //      _prog_addressT MACAddressAddress;
    //      MACAddressAddress.next = 0x157F8;
    //      _memcpy_p2d24((char*)&AppConfig.MyMACAddr, MACAddressAddress, sizeof(AppConfig.MyMACAddr));
    //   }
    AppConfig.MyIPAddr.Val = MY_DEFAULT_IP_ADDR_BYTE1 | MY_DEFAULT_IP_ADDR_BYTE2 << 8ul | MY_DEFAULT_IP_ADDR_BYTE3 << 16ul | MY_DEFAULT_IP_ADDR_BYTE4 << 24ul;
    AppConfig.DefaultIPAddr.Val = AppConfig.MyIPAddr.Val;
    AppConfig.MyMask.Val = MY_DEFAULT_MASK_BYTE1 | MY_DEFAULT_MASK_BYTE2 << 8ul | MY_DEFAULT_MASK_BYTE3 << 16ul | MY_DEFAULT_MASK_BYTE4 << 24ul;
    AppConfig.DefaultMask.Val = AppConfig.MyMask.Val;
    AppConfig.MyGateway.Val = MY_DEFAULT_GATE_BYTE1 | MY_DEFAULT_GATE_BYTE2 << 8ul | MY_DEFAULT_GATE_BYTE3 << 16ul | MY_DEFAULT_GATE_BYTE4 << 24ul;
    AppConfig.PrimaryDNSServer.Val = MY_DEFAULT_PRIMARY_DNS_BYTE1 | MY_DEFAULT_PRIMARY_DNS_BYTE2 << 8ul | MY_DEFAULT_PRIMARY_DNS_BYTE3 << 16ul | MY_DEFAULT_PRIMARY_DNS_BYTE4 << 24ul;
    AppConfig.SecondaryDNSServer.Val = MY_DEFAULT_SECONDARY_DNS_BYTE1 | MY_DEFAULT_SECONDARY_DNS_BYTE2 << 8ul | MY_DEFAULT_SECONDARY_DNS_BYTE3 << 16ul | MY_DEFAULT_SECONDARY_DNS_BYTE4 << 24ul;

    // Load the default Admin UserName and Password
    memcpypgm2ram(AppConfig.AdminUser, (ROM void*) MY_DEFAULT_ADMIN_USER, 16);
    memcpypgm2ram(AppConfig.AdminPassword, (ROM void*) MY_DEFAULT_ADMIN_PASSWORD, 16);

    // SNMP Community String configuration
#if defined(STACK_USE_SNMP_SERVER)
    {
        BYTE i;
        static ROM char * ROM cReadCommunities[] = SNMP_READ_COMMUNITIES;
        static ROM char * ROM cWriteCommunities[] = SNMP_WRITE_COMMUNITIES;
        ROM char * strCommunity;

        for (i = 0; i < SNMP_MAX_COMMUNITY_SUPPORT; i++) {
            // Get a pointer to the next community string
            strCommunity = cReadCommunities[i];
            if (i >= sizeof (cReadCommunities) / sizeof (cReadCommunities[0]))
                strCommunity = "";

            // Ensure we don't buffer overflow.  If your code gets stuck here,
            // it means your SNMP_COMMUNITY_MAX_LEN definition in TCPIPConfig.h
            // is either too small or one of your community string lengths
            // (SNMP_READ_COMMUNITIES) are too large.  Fix either.
            if (strlenpgm(strCommunity) >= sizeof (AppConfig.readCommunity[0]))
                while (1);

            // Copy string into AppConfig
            strcpypgm2ram((char*) AppConfig.readCommunity[i], strCommunity);

            // Get a pointer to the next community string
            strCommunity = cWriteCommunities[i];
            if (i >= sizeof (cWriteCommunities) / sizeof (cWriteCommunities[0]))
                strCommunity = "";

            // Ensure we don't buffer overflow.  If your code gets stuck here,
            // it means your SNMP_COMMUNITY_MAX_LEN definition in TCPIPConfig.h
            // is either too small or one of your community string lengths
            // (SNMP_WRITE_COMMUNITIES) are too large.  Fix either.
            if (strlenpgm(strCommunity) >= sizeof (AppConfig.writeCommunity[0]))
                while (1);

            // Copy string into AppConfig
            strcpypgm2ram((char*) AppConfig.writeCommunity[i], strCommunity);
        }
    }
#endif

    // Load the default NetBIOS Host Name
    memcpypgm2ram(AppConfig.NetBIOSName, (ROM void*) MY_DEFAULT_HOST_NAME, 16);
    FormatNetBIOSName(AppConfig.NetBIOSName);

#if defined(WF_CS_TRIS)
    // Load the default SSID Name
    WF_ASSERT(sizeof (MY_DEFAULT_SSID_NAME) <= sizeof (AppConfig.MySSID));
    memcpypgm2ram(AppConfig.MySSID, (ROM void*) MY_DEFAULT_SSID_NAME, sizeof (MY_DEFAULT_SSID_NAME));
    AppConfig.SsidLength = sizeof (MY_DEFAULT_SSID_NAME) - 1;

    AppConfig.SecurityMode = MY_DEFAULT_WIFI_SECURITY_MODE;
    AppConfig.WepKeyIndex = MY_DEFAULT_WEP_KEY_INDEX;

    #if (MY_DEFAULT_WIFI_SECURITY_MODE == WF_SECURITY_OPEN)
    memset(AppConfig.SecurityKey, 0x00, sizeof (AppConfig.SecurityKey));
    AppConfig.SecurityKeyLength = 0;

    #elif MY_DEFAULT_WIFI_SECURITY_MODE == WF_SECURITY_WEP_40
    memcpypgm2ram(AppConfig.SecurityKey, (ROM void*) MY_DEFAULT_WEP_KEYS_40, sizeof (MY_DEFAULT_WEP_KEYS_40) - 1);
    AppConfig.SecurityKeyLength = sizeof (MY_DEFAULT_WEP_KEYS_40) - 1;

    #elif MY_DEFAULT_WIFI_SECURITY_MODE == WF_SECURITY_WEP_104
    memcpypgm2ram(AppConfig.SecurityKey, (ROM void*) MY_DEFAULT_WEP_KEYS_104, sizeof (MY_DEFAULT_WEP_KEYS_104) - 1);
    AppConfig.SecurityKeyLength = sizeof (MY_DEFAULT_WEP_KEYS_104) - 1;

    #elif (MY_DEFAULT_WIFI_SECURITY_MODE == WF_SECURITY_WPA_WITH_KEY)       || \
              (MY_DEFAULT_WIFI_SECURITY_MODE == WF_SECURITY_WPA2_WITH_KEY)      || \
              (MY_DEFAULT_WIFI_SECURITY_MODE == WF_SECURITY_WPA_AUTO_WITH_KEY)
    memcpypgm2ram(AppConfig.SecurityKey, (ROM void*) MY_DEFAULT_PSK, sizeof (MY_DEFAULT_PSK) - 1);
    AppConfig.SecurityKeyLength = sizeof (MY_DEFAULT_PSK) - 1;

    #elif (MY_DEFAULT_WIFI_SECURITY_MODE == WF_SECURITY_WPA_WITH_PASS_PHRASE)     || \
              (MY_DEFAULT_WIFI_SECURITY_MODE == WF_SECURITY_WPA2_WITH_PASS_PHRASE)    || \
              (MY_DEFAULT_WIFI_SECURITY_MODE == WF_SECURITY_WPA_AUTO_WITH_PASS_PHRASE)
    memcpypgm2ram(AppConfig.SecurityKey, (ROM void*) MY_DEFAULT_PSK_PHRASE, sizeof (MY_DEFAULT_PSK_PHRASE) - 1);
    AppConfig.SecurityKeyLength = sizeof (MY_DEFAULT_PSK_PHRASE) - 1;

    #else
        #error "No security defined"
    #endif /* MY_DEFAULT_WIFI_SECURITY_MODE */

#endif

#if defined(USE_DEE_EMU)
    {
        DWORD c;

        DataEEReadArray((unsigned char *)&c, ADDRESS_TCPIP_APP_VERSION, 4);
        if (c == 0x61616161)
            DataEEReadArray((unsigned char *) &AppConfig, ADDRESS_TCPIP_APP_VERSION+4, sizeof (AppConfig));
        else
            SaveAppConfig(&AppConfig);
    }
#elif defined(EEPROM_CS_TRIS)
    {
        BYTE c;

        // When a record is saved, first byte is written as 0x61 to indicate
        // that a valid record was saved.  Note that older stack versions
        // used 0x60.  This change has been made to so old EEPROM contents
        // will get overwritten.  The AppConfig() structure has been changed,
        // resulting in parameter misalignment if still using old EEPROM
        // contents.
        XEEReadArray(0x0000, &c, 1);
        if (c == 0x61u)
            XEEReadArray(0x0001, (BYTE*) & AppConfig, sizeof (AppConfig));
        else
            SaveAppConfig();
    }
#elif defined(SPIFLASH_CS_TRIS)
    {
        BYTE c;

        SPIFlashReadArray(0x0000, &c, 1);
        if (c == 0x61u)
            SPIFlashReadArray(0x0001, (BYTE*) & AppConfig, sizeof (AppConfig));
        else
            SaveAppConfig();
    }
#endif
}
void SaveAppConfig(const APP_CONFIG *ptrAppConfig) {
#if defined(USE_DEE_EMU)
    DWORD version=0x61616161;
    DataEEWriteArray((unsigned char *)&version, ADDRESS_TCPIP_APP_VERSION, 4);
    DataEEWriteArray((unsigned char *)ptrAppConfig, ADDRESS_TCPIP_APP_VERSION+4, sizeof(AppConfig));
#elif defined(EEPROM_CS_TRIS)
#elif defined(SPIFLASH_CS_TRIS)
#endif
}
]]>
                </Section>
                <Section Name="Main" Option="chkTCPIP">
<![CDATA[
// --------------------------------------------------------------------
// Functions used in VGDD TCPIP demo app
// --------------------------------------------------------------------
void TemperatureChanged(void) {
#if defined(ID_Screen1_txtTemperature)
    SLIDER *pSld;
    STATICTEXT *pTxt;

    pTxt = (STATICTEXT *) GOLFindObject(ID_Screen1_txtTemperature);
    sprintf(pTxt->pText, "%i.C", intTemperature);
    SetState(pTxt, ST_DRAW);
    pSld = (SLIDER *) GOLFindObject(ID_Screen1_Slider1);
    if (intTemperature != (pSld)->pos) { // If it has been changed from web page, update the slider
        SldSetPos(pSld, intTemperature);
        SetState(pSld, SLD_DRAW);
    }
#endif
}

void WriteMessageFromWeb(char* cDest) {
#if defined(ID_Screen1_txtMessageFromWeb)
    if (strlen(cDest) < 32u) {
        STATICTEXT *pTxt;
        pTxt = (STATICTEXT *) (GOLFindObject(ID_Screen1_txtMessageFromWeb));
        if (pTxt != NULL) {
            strcpy((char*) pTxt->pText, (char*) cDest);
            SetState(pTxt, ST_DRAW);
        }
    }
#endif
}

void SwitchLedFromWeb(WORD num) {
#if defined(ID_Screen1_btnLED0)
    XCHAR buffer[32];
    BUTTON *pBtn;
    pBtn=(BUTTON *)(GOLFindObject(ID_Screen1_btnLED0+num));
    if(pBtn != NULL) {
        if(LedState[num]) {
            CreateScheme_ButtonOn(); // Ensure that the needed scheme is created the first time
            GOLSetScheme(pBtn,GOLScheme_ButtonOn);
            sprintf(buffer,"Led %i turned ON",num);
        } else {
            CreateScheme_ButtonOff(); // Ensure that the needed scheme is created the first time
            GOLSetScheme(pBtn,GOLScheme_ButtonOff);
            sprintf(buffer,"Led %i turned OFF",num);
        }
        SetState(pBtn, BTN_DRAW);
        WriteMessageFromWeb(buffer);
    }
#endif
}

void TFTShowMyIp(void) {
#if defined(ID_Screen1_txtMessageFromWeb)
    STATICTEXT *pTxt;
    pTxt = (STATICTEXT *) (GOLFindObject(ID_Screen1_txtMessageFromWeb));
    if (pTxt != NULL) {
        BYTE digits[4];
        BYTE i;
        extern XCHAR Screen1_txtMessageFromWeb_Text[];
        char *pTxtText;
        pTxtText = &Screen1_txtMessageFromWeb_Text[0];
        strcpypgm2ram((char *) pTxtText, "My IP: ");
        for (i = 0; i < 4u; i++) {
            if (i)
                strcatpgm2ram((char *) pTxtText, ".");
            uitoa(AppConfig.MyIPAddr.v[i], digits);
            strcatpgm2ram((char *) pTxtText, digits);
        }
        SetState(pTxt, ST_DRAW);
    }
#endif
}

]]>
                </Section>
                <Section Name="MainHeader" Option="chkTCPIP">
<![CDATA[
// --------------------------------------------------------------------
// Functions used in VGDD TCPIP demo app
// --------------------------------------------------------------------
void TemperatureChanged(void);
void WriteMessageFromWeb(char* cDest);
void SwitchLedFromWeb(WORD num);
void TFTShowMyIp(void);
]]>
                </Section>
            </Code>
        </Group>
        <Group Name="WiFi">
            <Project>
                <Folder Name="Source Files/TCPIP App" Option="chkWiFi">
                    <AddVGDDFile>WF_Config.c</AddVGDDFile>
                    <AddVGDDFile>WF_Config.h</AddVGDDFile>
                    <AddVGDDFile>WFEasyConfig.c</AddVGDDFile>
                    <AddVGDDFile DestDir="TCPIP Stack">WFEasyConfig.h</AddVGDDFile>
                </Folder>
                <Folder Name="Source Files/TCPIP Stack/WiFi" Option="chkWiFi">
                    <AddFile>$MAL/TCPIP Stack/WiFi/WF_Eint.c</AddFile>
                    <AddFile>$MAL/TCPIP Stack/WiFi/WF_pbkdf2.c</AddFile>
                    <AddFile>$MAL/TCPIP Stack/WiFi/WF_Spi.c</AddFile>
                    <AddFile>$MAL/TCPIP Stack/WiFi/WFConnectionAlgorithm.c</AddFile>
                    <AddFile>$MAL/TCPIP Stack/WiFi/WFConnectionManager.c</AddFile>
                    <AddFile>$MAL/TCPIP Stack/WiFi/WFConnectionProfile.c</AddFile>
                    <AddFile>$MAL/TCPIP Stack/WiFi/WFConsole.c</AddFile>
                    <AddFile>$MAL/TCPIP Stack/WiFi/WFConsoleIfconfig.c</AddFile>
                    <AddFile>$MAL/TCPIP Stack/WiFi/WFConsoleIwconfig.c</AddFile>
                    <AddFile>$MAL/TCPIP Stack/WiFi/WFConsoleIwpriv.c</AddFile>
                    <AddFile>$MAL/TCPIP Stack/WiFi/WFConsoleMsgHandler.c</AddFile>
                    <AddFile>$MAL/TCPIP Stack/WiFi/WFConsoleMsgs.c</AddFile>
                    <AddFile>$MAL/TCPIP Stack/WiFi/WFDataTxRx.c</AddFile>
                    <AddFile>$MAL/TCPIP Stack/WiFi/WFDebugStrings.c</AddFile>
                    <AddFile>$MAL/TCPIP Stack/WiFi/WFDriverCom.c</AddFile>
                    <AddFile>$MAL/TCPIP Stack/WiFi/WFDriverRaw.c</AddFile>
                    <AddFile>$MAL/TCPIP Stack/WiFi/WFEventHandler.c</AddFile>
                    <AddFile>$MAL/TCPIP Stack/WiFi/WFInit.c</AddFile>
                    <AddFile>$MAL/TCPIP Stack/WiFi/WFMac.c</AddFile>
                    <AddFile>$MAL/TCPIP Stack/WiFi/WFMgmtMsg.c</AddFile>
                    <AddFile>$MAL/TCPIP Stack/WiFi/WFParamMsg.c</AddFile>
                    <AddFile>$MAL/TCPIP Stack/WiFi/WFPowerSave.c</AddFile>
                </Folder>
            </Project>
            <Code>
                <Section Name="HardwareProfile" Option="chkWiFi">
<![CDATA[
// --------------------------------------------------------------------
// IOS FOR WiFi Module
// --------------------------------------------------------------------
#define WF_CS_TRIS           (TRISDbits.TRISD14) 
#define WF_CS_IO             (LATDbits.LATD14)   
#define WF_SDI_TRIS          (TRISFbits.TRISF4)  // MOSI4
#define WF_SCK_TRIS          (TRISFbits.TRISF13) // SCK4
#define WF_SDO_TRIS          (TRISFbits.TRISF5)  // MISO4
#define WF_RESET_TRIS        (TRISBbits.TRISB12)
#define WF_RESET_IO          (LATBbits.LATB12)
#define WF_SSPBUF            (SPI4BUF)
#define WF_SPISTAT           (SPI4STAT)
#define WF_SPISTATbits       (SPI4STATbits)
#define WF_SPICON1           (SPI4CON)
#define WF_SPICON1bits       (SPI4CONbits)
#define WF_SPI_BRG           (SPI4BRG)
#define WF_MAX_SPI_FREQ      (10000000ul) // Hz
#define WF_HIBERNATE_TRIS    (TRISBbits.TRISB15)
#define WF_HIBERNATE_IO      (PORTBbits.RB15)

#define MRF24W_IN_SPI2       // This is to make WF_Eint.c handle INT3 interrupts, otherwise the module assumes MRF24WB0MA is on INT1
#define WF_INT_TRIS          (TRISAbits.TRISA14) // INT3
#define WF_INT_IO            (PORTAbits.RA14)
#define WF_INT_EDGE          (INTCONbits.INT3EP)
#define WF_INT_IE            (IEC0bits.INT3IE)
#define WF_INT_IF            (IFS0bits.INT3IF)
#define WF_INT_IE_CLEAR      IEC0CLR
#define WF_INT_IF_CLEAR      IFS0CLR
#define WF_INT_IE_SET        IEC0SET
#define WF_INT_IF_SET        IFS0SET
#define WF_INT_BIT           0x00008000
#define WF_INT_IPCSET        IPC3SET
#define WF_INT_IPCCLR        IPC3CLR
#define WF_INT_IPC_MASK      0xFF000000
#define WF_INT_IPC_VALUE     0x0C000000
#define WF_SPI_IE_CLEAR      IEC1CLR
#define WF_SPI_IF_CLEAR      IFS1CLR
#define WF_SPI_INT_BITS      0x00000700
]]>
                </Section>
                <Section Name="MainHead" Option="chkWiFi">
<![CDATA[
static void WF_Connect(void);
// used for WiFi assertions 
#ifdef WF_DEBUG
	#define WF_MODULE_NUMBER   WF_MODULE_MAIN_DEMO
#endif
]]>
                </Section>
                <Section Name="MainBeforeLoop" Option="chkWiFi">
<![CDATA[
    WF_Connect();
]]>
                </Section>
                <Section Name="Main" Option="chkWiFi">
<![CDATA[
 /*****************************************************************************
 * FUNCTION: WF_Connect
 *
 * RETURNS:  None
 *
 * PARAMS:   None
 *
 *  NOTES:   Connects to an 802.11 network.  Customize this function as needed
 *           for your application.
 *****************************************************************************/
static void WF_Connect(void) {
    UINT8 ConnectionProfileID;
    UINT8 channelList[] = MY_DEFAULT_CHANNEL_LIST;
    #if defined(WF_USE_POWER_SAVE_FUNCTIONS)
    BOOL PsPollEnabled;
    #endif

    /* create a Connection Profile */
    WF_CPCreate(&ConnectionProfileID);

    #if defined(STACK_USE_UART)
    putrsUART("Set SSID\r\n");
    #endif
    WF_CPSetSsid(ConnectionProfileID,
            AppConfig.MySSID,
            AppConfig.SsidLength);

    #if defined(STACK_USE_UART)
    putrsUART("Set Network Type\r\n");
    #endif
    WF_CPSetNetworkType(ConnectionProfileID, MY_DEFAULT_NETWORK_TYPE);

    #if defined(STACK_USE_UART)
    putrsUART("Set Scan Type\r\n");
    #endif
    WF_CASetScanType(MY_DEFAULT_SCAN_TYPE);

    #if defined(STACK_USE_UART)
    putrsUART("Set Channel List\r\n");
    #endif
    WF_CASetChannelList(channelList, sizeof (channelList));

    #if defined(STACK_USE_UART)
    putrsUART("Set list retry count\r\n");
    #endif
    WF_CASetListRetryCount(MY_DEFAULT_LIST_RETRY_COUNT);

    #if defined(STACK_USE_UART)
    putrsUART("Set Event Notify\r\n");
    #endif
    WF_CASetEventNotificationAction(MY_DEFAULT_EVENT_NOTIFICATION_LIST);

    #if defined(WF_USE_POWER_SAVE_FUNCTIONS)
    PsPollEnabled = (MY_DEFAULT_PS_POLL == WF_ENABLED);
    if (!PsPollEnabled) {
        /* disable low power (PS-Poll) mode */
        #if defined(STACK_USE_UART)
        putrsUART("Disable PS-Poll\r\n");
        #endif
        WF_PsPollDisable();
    }
    else {
        /* Enable low power (PS-Poll) mode */
        #if defined(STACK_USE_UART)
        putrsUART("Enable PS-Poll\r\n");
        #endif
        WF_PsPollEnable(TRUE);
    }
    #endif
    #if defined(STACK_USE_UART)
    putrsUART("Set Beacon Timeout\r\n");
    #endif
    WF_CASetBeaconTimeout(40);

    /* Set Security */
    #if (MY_DEFAULT_WIFI_SECURITY_MODE == WF_SECURITY_OPEN)
        #if defined(STACK_USE_UART)
    putrsUART("Set Security (Open)\r\n");
        #endif
    #elif (MY_DEFAULT_WIFI_SECURITY_MODE == WF_SECURITY_WEP_40)
        #if defined(STACK_USE_UART)
    putrsUART("Set Security (WEP40)\r\n");
        #endif
    #elif (MY_DEFAULT_WIFI_SECURITY_MODE == WF_SECURITY_WEP_104)
        #if defined(STACK_USE_UART)
    putrsUART("Set Security (WEP104)\r\n");
        #endif
    #elif MY_DEFAULT_WIFI_SECURITY_MODE == WF_SECURITY_WPA_WITH_KEY
        #if defined(STACK_USE_UART)
    putrsUART("Set Security (WPA with key)\r\n");
        #endif
    #elif MY_DEFAULT_WIFI_SECURITY_MODE == WF_SECURITY_WPA2_WITH_KEY
        #if defined(STACK_USE_UART)
    putrsUART("Set Security (WPA2 with key)\r\n");
        #endif
    #elif MY_DEFAULT_WIFI_SECURITY_MODE == WF_SECURITY_WPA_WITH_PASS_PHRASE
        #if defined(STACK_USE_UART)
    putrsUART("Set Security (WPA with pass phrase)\r\n");
        #endif
    #elif MY_DEFAULT_WIFI_SECURITY_MODE == WF_SECURITY_WPA2_WITH_PASS_PHRASE
        #if defined(STACK_USE_UART)
    putrsUART("Set Security (WPA2 with pass phrase)\r\n");
        #endif
    #elif MY_DEFAULT_WIFI_SECURITY_MODE == WF_SECURITY_WPA_AUTO_WITH_KEY
        #if defined(STACK_USE_UART)
    putrsUART("Set Security (WPA with key, auto-select)\r\n");
        #endif
    #elif MY_DEFAULT_WIFI_SECURITY_MODE == WF_SECURITY_WPA_AUTO_WITH_PASS_PHRASE
        #if defined(STACK_USE_UART)
    putrsUART("Set Security (WPA with pass phrase, auto-select)\r\n");
        #endif
    #endif /* MY_DEFAULT_WIFI_SECURITY_MODE */

    WF_CPSetSecurity(ConnectionProfileID,
            AppConfig.SecurityMode,
            AppConfig.WepKeyIndex, /* only used if WEP enabled */
            AppConfig.SecurityKey,
            AppConfig.SecurityKeyLength);
    #if defined(STACK_USE_UART)
    putrsUART("Start WiFi Connect\r\n");
    #endif
    WF_CMConnect(ConnectionProfileID);
}
]]>
                </Section>
            </Code>
        </Group>"
        <Group Name="PCAP">
            <Project>
                <Folder Name="Header Files/Board Support Package" Option="chkPCAP">
                    <RemoveFile>TouchScreen.h</RemoveFile>
                    <RemoveFile>TouchScreenResistive.h</RemoveFile>
                    <AddVGDDFile>TouchScreenCapacitive.h</AddVGDDFile>
                </Folder>
                <Folder Name="Source Files/Board Support Package" Option="chkPCAP">
                    <RemoveFile>TouchScreen.c</RemoveFile>
                    <RemoveFile>TouchScreenResistive.c</RemoveFile>
                    <AddVGDDFile>TouchScreenCapacitive.c</AddVGDDFile>
                    <AddVGDDFile>i2c_sw.c</AddVGDDFile>
                </Folder>
            </Project>
            <Code>
                <Section Name="MainHeader" Option="chkPCAP">
<![CDATA[
#include "TouchScreenCapacitive.h"
]]>
                </Section>
                <Section Name="HardwareProfile" Option="chkPCAP">
<![CDATA[
//#define USE_CAPACITIVE_CONTROLLER_MTCH6301
]]>
                </Section>
                <Section Name="InitializeBoard" Option="chkPCAP" Order="1">
<![CDATA[
    TRISCbits.TRISC13 = 0;

    LATCbits.LATC13 = 0; //Reset PCAP I2C
    DelayMs(500);
    LATCbits.LATC13 = 1;

    I2C_Init();
    TRISDbits.TRISD0 = 1; //Input for INT pin for PCAP

    IEC0bits.INT0IE = 0; // disable INT1
    INTCONbits.INT0EP = 1; // rising edge trigger
    IPC0bits.INT0IP = 4;
    IFS0bits.INT0IF = 0; // clear the interrupt flag
    IEC0bits.INT0IE = 1; // enable INT0

    PCapX[0].Val = -1;
    PCapY[0].Val = -1;
                    ]]>
                </Section>
            </Code>
        </Group>
    </Groups>
    <Checks>
        <Check ExpBoardIds="LCC_BOARD" Evaluate="chkLCCInternalMemory | chkLCCExternalMemory" Warning="You must select either Internal or External memory option" />
        <Check ExpBoardIds="GFX_S1D13517,GFX_SSD1926,MEB_BOARD,TECHTOYS_SSD1963_EVK" Evaluate="chkPMP8 | chkPMP16"  Warning="You must select either 8 or 16 bits PMP mode" />
    </Checks>
</MplabXWizard>